{"file_contents":{"app/src/main/jni/Android.mk":{"content":"LOCAL_PATH := $(call my-dir)\nMAIN_LOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE  := MRKILLER2.5\n\n\nLOCAL_ARM_MODE := arm\nLOCAL_CFLAGS := -Wno-error=format-security -fpermissive -fvisibility=hidden -fvisibility-inlines-hidden\nLOCAL_CFLAGS += -fno-rtti -fno-exceptions -g0 -fomit-frame-pointer -ffunction-sections -fdata-sections\nLOCAL_CPPFLAGS += -fvisibility=hidden -ffunction-sections -fdata-sections\nLOCAL_LDFLAGS += -Wl,--strip-all\n\n# Here you add the cpp file\nLOCAL_C_INCLUDES += $(MAIN_LOCAL_PATH)\nLOCAL_SRC_FILES := src/gringo.cpp \\\n\tsrc/Substrate/hde64.c \\\n\tsrc/Substrate/SubstrateDebug.cpp \\\n\tsrc/Substrate/SubstrateHook.cpp \\\n\tsrc/Substrate/SubstratePosixMemory.cpp \\\n\tsrc/KittyMemory/KittyMemory.cpp \\\n\tsrc/KittyMemory/MemoryPatch.cpp \\\n    src/KittyMemory/MemoryBackup.cpp \\\n    src/KittyMemory/KittyUtils.cpp \\\n\tsrc/Unity/Vector2.hpp \\\n    src/Unity/Vector3.hpp \\\n    src/Unity/Quaternion.hpp \\\n    \n    \nLOCAL_LDLIBS := -llog -landroid\n\ninclude $(BUILD_SHARED_LIBRARY)\n","size_bytes":1000},"app/src/main/jni/Application.mk":{"content":"APP_ABI := armeabi-v7a\nAPP_PLATFORM := android-18\nAPP_STL := gnustl_static\nAPP_OPTIM := release\nAPP_CPPFLAGS := -std=c++14 -fno-rtti -fno-exceptions -DNDEBUG -Wall -fpermissive -fpic\nAPP_LDFLAGS := -llog\nAPP_THIN_ARCHIVE := true\nAPP_PIE \t\t:= true\n","size_bytes":247},"app/src/main/jni/src/gringo.cpp":{"content":"#include <pthread.h>\n#include <jni.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <src/Substrate/SubstrateHook.h>\n#include \"src/Unity/Quaternion.hpp\"\n#include \"src/Unity/Vector3.hpp\"\n#include \"src/Unity/Vector3.hpp\"\n#include \"src/Unity/Unity.h\"\n#include \"src/Unity/Hook.h\"\n#include \"src/Unity/Global.h\"\n#include \"src/CANVAS/Bools.h\"\n#include \"src/CANVAS/ESP.h\"\n#include \"KittyMemory/MemoryPatch.h\"\n#include \"Includes/Logger.h\"\n#include \"Boolean.h\"\n#include \"Includes/obfuscate.h\"\n//#include \"Includes/Macros.h\"\n#define targetLibName OBFUSCATE(\"libFileA.so\")\n\n#define OBFUSCATE_BNM(str) str \n\n# define HOOK_LIB(offset, ptr, orig) MSHookFunction((void *)getRealOffset(offset), (void *)ptr, (void **)&orig)\n\nusing namespace std;\n\nESP espOverlay;\nVector3 InimigoLocation = Vector3(0, 0, 0);\n\nextern \"C\" {\nJNIEXPORT jboolean JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_EnableSounds(\nJNIEnv *env,\njobject activityObject) {\nreturn true;\n}\n\nJNIEXPORT jstring JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_ForegroundGravity(JNIEnv *env,jobject activityObject) {\njstring str = env->NewStringUTF((OBFUSCATE(\"GOD X MODS TEAM\")));\nreturn str;\n}\n\nJNIEXPORT jstring JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_Gravity(JNIEnv *env,jobject activityObject) {\njstring str = env->NewStringUTF((OBFUSCATE(\"100% ANTI BAN\")));\nreturn str;\n}\n\nJNIEXPORT jobjectArray JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_getFeatureList(JNIEnv *env, jobject activityObject) {\njobjectArray ret;\n\nconst char *features[] = {\n\nOBFUSCATE(\"CT_ MENU AIM\"),//0\nOBFUSCATE(\"Toggle_ AIM BOT\"),//1\nOBFUSCATE(\"Toggle55_ AIMKILL\"),//2\nOBFUSCATE(\"SB_ AIM FOV%_0_360\"),//3\nOBFUSCATE(\"SB_ RUN SPEED%_0_5\"),//4\nOBFUSCATE(\"Toggle_ AIM FIRE\"),//5\nOBFUSCATE(\"Toggle_ AIM SCOPE\"),//6\nOBFUSCATE(\"Toggle_ AIM VISBEL\"),//7\nOBFUSCATE(\"CT_ MENU ESP\"),//8\nOBFUSCATE(\"Toggle_ ESP GRENDA\"),//9\nOBFUSCATE(\"Toggle_ ESP FIRE BLUE\"),//10\nOBFUSCATE(\"Toggle_ ESP INFO\"),//11\nOBFUSCATE(\"CT_ MENU FLY\"),//12\nOBFUSCATE(\"Toggle_ FLY HACK\"),//13\nOBFUSCATE(\"SB_ FLY HEIGHT_0_175\"),//14\nOBFUSCATE(\"SB_ FLY SPEED_0_10000\"),//15\nOBFUSCATE(\"Toggle_ TELEKILL (FLY)\"),//16\nOBFUSCATE(\"Toggle_ TELEPORT PRO\"),//17\nOBFUSCATE(\"Toggle_ Ghost Hack V2\"),//18\nOBFUSCATE(\"CT_ MENU OTHER\"),//19\nOBFUSCATE(\"Toggle_ AUTO CHANGE (GUN)\"),//20\nOBFUSCATE(\"Toggle_ AIM WITH MOVEMENT\"),//21\nOBFUSCATE(\"Toggle_ MEDKIT RUN\"),//22\nOBFUSCATE(\"Toggle2_ BLACK BODY\"),//23\nOBFUSCATE(\"Toggle_ DIMOND HACK\"),//24\nOBFUSCATE(\"Toggle_ GOLD HACK\"),//25\nOBFUSCATE(\"Toggle2_ NO SCOPE\"),//26\nOBFUSCATE(\"Toggle2_ ULTIMATE AMMO\"),//27\nOBFUSCATE(\"Toggle_ V (BADGE)\"),//28\nOBFUSCATE(\"Toggle_ REMOVE GUEST\"),//29\n\nOBFUSCATE(\"Toggle_ ESP LINE TRY\"),//28\nOBFUSCATE(\"Toggle_ ESP BOX TRY\"),//29\n\n};\n\nint Total_Feature = (sizeof features / sizeof features[0]); //Now you dont have to manually update the number everytime;\nret = (jobjectArray) env->NewObjectArray(Total_Feature, env->FindClass(\"java/lang/String\"),env->NewStringUTF(\"\"));\nint i;\nfor (i = 0; i < Total_Feature; i++)\nenv->SetObjectArrayElement(ret, i, env->NewStringUTF(features[i]));\nreturn (ret);\n}\n\nJNIEXPORT void JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_Changes(JNIEnv *env, jobject activityObject, jint feature, jint value) {\n    \nswitch (feature) {\n\ncase 0:\nbreak;\n    \ncase 1:\nStartMenu = !StartMenu;\nbreak;\n\ncase 2:\n//AimKill = !AimKill;\nbreak;\n\ncase 3:\nAim_Fov = value;\nbreak;\n\ncase 4:\nSpeed = (int)value;\nbreak;\n\ncase 5:\nAimFire = !AimFire;\nbreak;\n\ncase 6:\nAimScope = !AimScope;\nbreak;\n\ncase 7:\nCheckVisible = !CheckVisible;\nbreak;\n\ncase 8:\nbreak;\n\ncase 9:\nEspGrenade = !EspGrenade;\nbreak;\n\ncase 10:\nESPFire2 = !ESPFire2;\nbreak;\n\ncase 11:\nEspAlerta = !EspAlerta;\nbreak;\n\ncase 12:\nbreak;\n\ncase 13:\nHackFly = !HackFly;\nbreak;\n\ncase 14:\nFlyHack = value;\nbreak;\n\ncase 15:\nFlyspeed = value;\nbreak;\n\ncase 16:\nTelePro = !TelePro;\nbreak;\n\ncase 17:\nTelePro2 = !TelePro2;\nbreak;\n\ncase 18:\nGhostHack = !GhostHack;\nbreak;\n\ncase 19:\nbreak;\n\ncase 20:\nautotroca = !autotroca;\nbreak;\n\ncase 21:\nAimMove = !AimMove;\nif (AimMove) {\nAimMovement.Modify();\n} else {\nAimMovement.Restore();\n}\nbreak;\n\ncase 22:\nMedikitCorriendo = !MedikitCorriendo;\nif (MedikitCorriendo) {\nMedikit.Modify();\nMedikit2.Modify();\n} else {\nMedikit2.Restore();\nMedikit.Restore();\n}\nbreak;\n\ncase 23:\nKMHack1 = !KMHack1;\nif (KMHack1) {\nBlackbody.Modify();\n} else {\nBlackbody.Restore();\n}\nbreak;\n\ncase 24:\nKMHack2 = !KMHack2;\nif (KMHack2) {\nDiamondHack.Modify();\n} else {\nDiamondHack.Restore();\n}\nbreak;\n\ncase 25:\nKMHack3 = !KMHack3;\nif (KMHack3) {\nGoldHack.Modify();\n} else {\nGoldHack.Restore();\n}\nbreak;\n\ncase 26:\nKMHack4 = !KMHack4;\nif (KMHack4) {\nNoScope.Modify();\n} else {\nNoScope.Restore();\n}\nbreak;\n\ncase 27:\nKMHack5 = !KMHack5;\nif (KMHack5) {\nUltimateammo.Modify();\n} else {\nUltimateammo.Restore();\n}\nbreak;\n\ncase 28:\nKMHack6 = !KMHack6;\nif (KMHack6) {\nGetVBadge.Modify();\n} else {\nGetVBadge.Restore();\n}\nbreak;\n\ncase 29:\nKMHack7 = !KMHack7;\nif (KMHack7) {\nResetGuest.Modify();\n} else {\nResetGuest.Restore();\n}\nbreak;\n\ncase 30:\nKMHack7 = !KMHack7;\nisPlayerLine = !isPlayerLine;\nbreak;\n\ncase 31:\nKMHack7 = !KMHack7;\nisPlayerBox = !isPlayerBox;\nbreak;\n\n}\n}\n}\n\nstatic void *GetLeech(void *lammer) {\n    void *(*_leech)(void *lammer) = (void *(*)(void *))getRealOffset(address.GetHeadTF);\n    return _leech(lammer);\n}\n\nVector3 GetHeadPosition(void* player) {\n    return get_position_Injected(GetLeech(player));\n}\n\nstatic void *GetHipLeech(void *lammer) {\n    void *(*_leech)(void *lammer) = (void *(*)(void *))getRealOffset(address.HipTF);\n    return _leech(lammer);\n}\n\nVector3 GetHipPosition(void* player) {\n    return get_position_Injected(GetHipLeech(player));\n}\n\nstatic void *GetToeLeech(void *lammer) {\n    void *(*_leech)(void *lammer) = (void *(*)(void *))getRealOffset(address.ToeTF);\n    return _leech(lammer);\n}\n\nVector3 GetToePosition(void* player) {\n    return get_position_Injected(GetToeLeech(player));\n}\n\nstatic void *GetLShoulderLeech(void *lammer) {\n    void *(*_leech)(void *lammer) = (void *(*)(void *))getRealOffset(address.LShoulder);\n    return _leech(lammer);\n}\n\nVector3 GetLShoulderPosition(void* player) {\n    return get_position_Injected(GetLShoulderLeech(player));\n}\n\nstatic void *GetRShoulderLeech(void *lammer) {\n    void *(*_leech)(void *lammer) = (void *(*)(void *))getRealOffset(address.RShoulder);\n    return _leech(lammer);\n}\n\nVector3 GetRShoulderPosition(void* player) {\n    return get_position_Injected(GetRShoulderLeech(player));\n}\n\nVector3 CameraMain(void* player) {\n    return get_position_Injected(*(void**) ((uint64_t) player + address.MainCameraTransform));\n}\n\nstatic void spofNick(void *players) {\nvoid (*_spof_nick)(void *player, monoString *nick) = (void (*)(void *, monoString *))getRealOffset(address.FakeName);\n_spof_nick(players, CreateString((OBFUSCATE(\"[FF0000]YOUTUBE : [00FF00]GOD X MODS TEAM\"))));\n}\n\nvoid *GetVehicle(void * Match) {\nif (!Match) return nullptr;\nvoid* veiculo = nullptr;\nvoid* PlayerClient = GetLocalPlayer2(Match);//0\nvoid* vehicle = GetLocalVehicle(PlayerClient);\nbool dirigindo = get_IsDriver(PlayerClient);\nif (vehicle != nullptr && !get_IsPassenger(PlayerClient)) {\nveiculo = vehicle;\n}\nreturn veiculo;\n}\n\nbool Visible_Check(void * player) {\nif(player != NULL) {\nvoid *hitObj = NULL;\nVector3 cameraLocation = get_position_Injected(get_transform(get_main()));\nVector3 headLocation = get_position_Injected(get_transform(get_HeadCollider(player)));\nreturn !Physics_Raycast(cameraLocation, headLocation, 12, &hitObj);\n}\nreturn false;\n}\n\n/*namespace Save{\n\tvoid* DamageInfo;\n\tvoid* DamagerWeaponDynamicInfo;\n\tclock_t AimDelay;\n\tint AimFPS = (1000000 / 15);\n}\n\nvoid (*DamageInfo)(void*);\nvoid DamageInfoHook(void* Player){\n\treturn DamageInfo(Save::DamageInfo=Player);\n}\n\n\nstatic void AimSkill(void* Enemy) {\n    if (Enemy != nullptr) {\n        if(Save::DamageInfo != NULL && clock() > Save::AimDelay){\n            \n        Save::AimDelay = clock() + Save::AimFPS;\n        void* LocalPlayer = Current_Local_Player();\n        if (LocalPlayer && !get_isWatching(LocalPlayer)){\n\t\tvoid* WeaponOnHand = PlayerWeaponOnHand(LocalPlayer);\n        \n        *(int32_t*)((uintptr_t) Save::DamageInfo + 0xC) = 1;\n        *(void**)((uintptr_t) Save::DamageInfo + 0x18) = *(void**)((uintptr_t) LocalPlayer + 0x148);\n        *(void**)((uintptr_t) Save::DamageInfo + 0x18) = *(void**)((uintptr_t) LocalPlayer + 0xd38);\n        *(void**)((uintptr_t) Save::DamageInfo + 0x30) = WeaponOnHand;\n        *(Vector3*)((uintptr_t) Save::DamageInfo + 0x38) = CameraMain(LocalPlayer);\n        *(Vector3*)((uintptr_t) Save::DamageInfo + 0x44) = GetHeadPosition(Enemy);\n\t\t\n          Vector3 m_Head = GetHeadPosition(Enemy);\n          Vector3 m_HeadLocal = GetHeadPosition(Current_Local_Player());\n          void *WeaponHand = PlayerWeaponOnHand(Current_Local_Player());\n            if (WeaponHand != nullptr) {\n\t\t\t\tStartWholeBodyFiring(Current_Local_Player(),WeaponHand);\n                LateKillUpdate(Enemy, *(int *) ((long) WeaponHand + 0x58),\n                           get_PlayerID(Current_Local_Player()), Save::DamageInfo, GetWeapon(WeaponHand),\n                           m_HeadLocal, m_Head, *(monoList<float> *) ((long) Enemy + 0x8C0), 0, 0);\n\t\t\t\tStopFire(Current_Local_Player(),WeaponHand);\n            }\n        }\n    }\n}\n}\n\n\n/*void (*DamageInfo)(void* Player);\nvoid DamageInfoHook(void* Player){\nSave::DamageInfoo=Player;\nreturn DamageInfo(Player);\n}\n\nvoid PlayerTakeDamage(void* Player){\nvoid* Match = CurrentMatch();\nvoid* LocalPlayer1 = GetLocalPlayer2(Match);//1\nif ((StartMenu) && Match) {\nif(Save::DamageInfoo != NULL && clock() > Save::AimDelay){\nSave::AimDelay = clock() + AimFPS;\nif (Visible_Check(Player)) {\nif (Visible_Check != nullptr) {\nvoid * GetWeaponHand1 = GetWeaponOnHand1(LocalPlayer1);\nif (GetWeaponHand1 != nullptr) {\nVector3 HeadPOS1 = GetHeadPosition(Player);\n*(void**)((uintptr_t) Save::DamageInfoo + 0x18) = *(void**)((uintptr_t) LocalPlayer1 + 0x118);// protected IHAAMHPPLMG KFMGKCJMCAM; 2\nif (Save::DamageInfoo != nullptr) {\n*(void**)((uintptr_t) Save::DamageInfoo + 0x30) = GetWeaponHand1;\n*(Vector3*)((uintptr_t) Save::DamageInfoo + 0x38) = CameraPosition(LocalPlayer1);\n*(Vector3*)((uintptr_t) Save::DamageInfoo + 0x44) = HeadPOS1;\n*(int*) ((uintptr_t) Save::DamageInfoo + 0xC) = 1;\n*(void**)((uintptr_t) Save::DamageInfoo + 0x10);\nStartWholeBodyFiring(LocalPlayer1, GetWeaponHand1);\nTakeDamage(Player, *(int *) ((long) GetWeaponHand1 + 0x58),\nget_PlayerID(LocalPlayer1), Save::DamageInfoo, GetWeapon(GetWeaponHand1),\nCameraPosition(LocalPlayer1), HeadPOS1, *(monoList<float> *) ((long) Player + 0x82c), 0, 0);// private GameObject IGEHMJFLFLK;\nTakeDamagee(Player,Save::DamageInfoo,NULL,*(void**)((uintptr_t) Player + 0x80c),0);// private GameObject JHHABGNEDGC;\nStartFiring(LocalPlayer1, GetWeaponHand1);\nStopFire1(LocalPlayer1, GetWeaponHand1);\n}\n}\n}\n}\n}\n}\n}\n*/\n\n\n\nVector3 AlvoEnemyPos = Vector3(0, 0, 0);\nVector3 AlvoLocalPos = Vector3(0, 0, 0);\n\nvoid *GetClosestEnemy(void *match) {\nif(!match) {\nreturn NULL;\n}\n \nfloat shortestDistance = 99999.0f;\nfloat maxAngle = Aim_Fov;\nvoid* closestEnemy = NULL;\nvoid* LocalPlayer = GetLocalPlayer2(match);//2\nif(LocalPlayer != NULL && !get_IsDieing(LocalPlayer)) {\nmonoDictionary<uint8_t *, void **> *players = *(monoDictionary<uint8_t*, void **> **)((long)match + address.Dictionary);\nfor(int u = 0; u < players->getNumValues(); u++) {\nvoid* Player = players->getValues()[u];\nif(Player != NULL && !IsLocalTeammate(Player) && !get_IsDieing(Player) && IsVisible(Player) && get_MaxHP(Player)) {\n\nVector3 PlayerPos = GetHipPosition(Player);\nVector3 LocalPlayerPos = GetHeadPosition(LocalPlayer);\nVector3 CenterWS = GetAttackableCenterWS(LocalPlayer);\n\nif(StartMenu) {\nif(!CheckVisible) {\nif(FOV) {\nVector3 targetDir = Vector3::Normalized(PlayerPos - LocalPlayerPos);\nfloat angle = Vector3::Angle(targetDir, get_forward(get_transform(get_main()))) * 100;\nif(angle <= maxAngle) {\nif(angle < shortestDistance) {\nshortestDistance = angle;\nclosestEnemy = Player;\n}\n}\n}\n} else {\nif(maxAngle < shortestDistance) {\nshortestDistance = maxAngle;\nclosestEnemy = Player;\n}\n}\n}\n\nif (EspFire) {\nvoid *imo = get_imo(LocalPlayer);\nif (imo != NULL ) {\nset_esp(imo, CenterWS, PlayerPos);\n}\n}\n\nif (ESPFire2) {\nvoid *imo = get_imo(LocalPlayer);\nif (imo != NULL ) {\nset_esp2(imo, CenterWS, PlayerPos);\n}\n}\n\nif(CheckVisible) {\nVector3 targetDir = Vector3::Normalized(PlayerPos - LocalPlayerPos);\nfloat angle = Vector3::Angle(targetDir, get_forward(get_transform(get_main()))) * 100.0;\nif(angle <= maxAngle) {\nif(Visible_Check(Player)) {\nif(angle < shortestDistance) {\nshortestDistance = angle;\nclosestEnemy = Player;\n}\n}\n}\n} else {\nif(maxAngle < shortestDistance) {\nshortestDistance = maxAngle;\nclosestEnemy = Player;\n}\n}\n/*if (AimKill) {\n        \tAimSkill(closestEnemy);\n\t\t   }*/\n\n}\n}\n}\nreturn closestEnemy;\n}\n\n/*int pLoopDamage1 = 0;\nint WorkTakeDamage1 = 0;\nint LoopFire1 = 0;\nbool StartFire1 = true;\nbool StopFire22 = false;\n\nvoid *pCurrentLocalPlayer1 = nullptr;\nvoid *GetWeaponHand1 = nullptr;\n\nstruct DataRemote1 {\nvoid *DevilyRemote1 = nullptr;\nint32_t DevilyRemote2 = 0;\nvoid *DevilyRemote3 = nullptr;\nvoid *DevilyRemote4 = nullptr;\nint32_t DevilyRemote5 = 0;\nVector3 DevilyRemote6 = Vector3::Zero();\nVector3 DevilyRemote7 = Vector3::Zero();\nmonoList<float *> DevilyRemote8;\nvoid *DevilyRemote9 = nullptr;\nint32_t DevilyRemote10 = 0;\n}pData1 ;\n\nint32_t (*orig_TakeDamage1)(void *player, int32_t p_damage, void *get_KillerPlayerID, void *p_info, int WeaponDataID, Vector3 FirePos, Vector3 TargetPos, monoList<float *> CheckParams, void *p_idk1, int32_t p_idk2);\nint32_t hook_TakeDamage1(void *player, int32_t p_damage, void *get_KillerPlayerID, void *p_info, int WeaponDataID, Vector3 FirePos, Vector3 TargetPos, monoList<float *> CheckParams, void *p_idk1, int32_t p_idk2) {\nif(StartMenu) {\nif (Skill) {\npData1.DevilyRemote1 = player;\npData1.DevilyRemote2 = p_damage;\npData1.DevilyRemote3 = get_KillerPlayerID;\npData1.DevilyRemote4 = p_info;\npData1.DevilyRemote5 = WeaponDataID;\npData1.DevilyRemote6 = FirePos;\npData1.DevilyRemote7 = TargetPos;\npData1.DevilyRemote8 = CheckParams;\npData1.DevilyRemote9 = p_idk1;\npData1.DevilyRemote10 = p_idk2;\n} else {\npData1. DevilyRemote1 = nullptr;\n}\nreturn orig_TakeDamage1(player, p_damage, get_KillerPlayerID, p_info, WeaponDataID, FirePos, TargetPos, CheckParams, p_idk1, p_idk2);\n}\n}\n\nstatic void NetworkTakeDamage1(void * closestEnemy) {\nvoid* Match = CurrentMatch();\nif((StartMenu) && Match) {\nif (Skill && pData1.DevilyRemote1 != nullptr) {\npCurrentLocalPlayer1 = GetLocalPlayer2(Match);\nif(Save::DamageInfoo != NULL && clock() > Save::AimDelay){\nSave::AimDelay = clock() + AimFPS;\nif (Visible_Check(closestEnemy)) {\nvoid * GetWeaponHand1 = GetWeaponOnHand1(pCurrentLocalPlayer1);\nvoid* LocalCar = VehicleIAmIn(pCurrentLocalPlayer1);\nif (LocalCar != nullptr) {\nVector3 HeadPOS1 = GetHeadPosition(closestEnemy);\n*(void**)((uintptr_t) Save::DamageInfoo + 0x18) = *(void**)((uintptr_t) pCurrentLocalPlayer1 + 0x118);// protected IHAAMHPPLMG KFMGKCJMCAM; 2\n*(void**)((uintptr_t) Save::DamageInfoo + 0x30) = GetWeaponHand1;\n*(Vector3*)((uintptr_t) Save::DamageInfoo + 0x38) = CameraPosition(pCurrentLocalPlayer1);\n*(Vector3*)((uintptr_t) Save::DamageInfoo + 0x44) = HeadPOS1;\n*(int*) ((uintptr_t) Save::DamageInfoo + 0xC) = 1;\n*(void**)((uintptr_t) Save::DamageInfoo + 0x10);\nif (Skill) {\nStartFire1 = true;\nStopFire22 = false;\npLoopDamage1 = 15;\n}\nif (Skill) {\nTakeDamagee(closestEnemy,Save::DamageInfoo,NULL,*(void**)((uintptr_t) closestEnemy + 0x80c),0);// private GameObject JHHABGNEDGC;\norig_TakeDamage1(closestEnemy, pData1.DevilyRemote2, pData1.DevilyRemote3, pData1.DevilyRemote4, pData1.DevilyRemote5, pData1.DevilyRemote6, pData1.DevilyRemote7, pData1.DevilyRemote8, pData1.DevilyRemote9, pData1.DevilyRemote10);\nWorkTakeDamage1 = 18;\n}\nif (Skill) {\nStartWholeBodyFiring(pCurrentLocalPlayer1, GetWeaponHand1);\nLoopFire1 = 15;\n} \nif (StartFire1) {\nif (pCurrentLocalPlayer1) {\nif (GetWeaponHand1) {\nStartFiring(pCurrentLocalPlayer1, GetWeaponHand1);\n}\n}\nStartFire1 = true;\nStopFire22 = false;\n}\nif (StopFire1) {\nif (pCurrentLocalPlayer1) {\nif (GetWeaponHand1) {\nStopFire1(pCurrentLocalPlayer1,GetWeaponHand1);\n}\n}\nStartFire1 = false;\nStopFire22 = true;\n} \n}\n}\n}\n}\n}\n}\n*/\nstatic bool isReady() {\nreturn false;\n}\n\nlong StartIl2cpp;\nlong AbsoluteAddress(long Offset){\nif(StartIl2cpp == 0){\nStartIl2cpp = AfindLibrary(\"libil2cpp.so\");\nif(StartIl2cpp == 0){\nStartIl2cpp = 0;\n}\n}\nreturn StartIl2cpp + Offset;\n}\n\nvoid (*Update)(void* gamestartup);\nvoid _Update(void* gamestartup) {\nif(StartMenu) {\nvoid* Match = CurrentMatch();\nif ((AimScope || AimFire) && Match) {\nauto *PlayerClient = GetLocalPlayer2(Match);\nif (PlayerClient) {\n/* void* LocalPlayer = GetLocalPlayer(Match);\nif (LocalPlayer) {*/\ntS++;\nif (tS > 1 && autotroca) {\nauto now = steady_clock::now();\nauto elapsed = duration_cast<milliseconds>(now - lastSwapTime).count();\nif (elapsed >= 300) {\nsID = !sID;\nSwapWeapon(PlayerClient, sID, true);\ntS = 0;\nlastSwapTime = now;\n}\n}\n \nvoid* closestEnemy = GetClosestEnemy(Match);\nif (closestEnemy && !get_IsDieing(closestEnemy)) {\n\n/*if (Skill && pData1.DevilyRemote1 != nullptr) {\nNetworkTakeDamage1(closestEnemy);\n} \n++WorkTakeDamage1;\n++pLoopDamage1;\n++Save::AimDelay;\n++AimFPS;\n*/\nVector3 EnemyLocation = GetHeadPosition(closestEnemy);\nVector3 EnemyLocation2 = GetHeadPosition(PlayerClient);\nVector3 PlayerLocation = CameraMain(PlayerClient);//01\nVector3 CenterWS = GetAttackableCenterWS(PlayerClient);//02\n\nQuaternion PlayerLook = GetRotationToLocation(GetHeadPosition(closestEnemy), 0.1f, PlayerLocation);\nQuaternion PlayerLook2 = GetRotationToLocation(GetHipPosition(closestEnemy), 0.1f, PlayerLocation);\nQuaternion PlayerLook3 = GetRotationToLocation(GetToePosition(closestEnemy), 0.1f, PlayerLocation);\n\nfloat distance = Vector3::Distance(CenterWS, EnemyLocation);\nint Health = get_CurHP(closestEnemy);\n\nVector3 LocalPlayerPos = GetHeadPosition(PlayerClient);//03\nVector3 LocalPlayerPos2 = GetAttackableCenterWS(PlayerClient);//04\nVector3 PlayerPos = GetHeadPosition(closestEnemy);\n \nbool scope = get_IsSighting(PlayerClient);//05\nbool firing = IsFiring(PlayerClient);//06\nbool caido = get_IsDieing(closestEnemy);\nbool dirigindo = get_IsDriver(PlayerClient);\n \nif (StartMenu) {\nspofNick(PlayerClient);//07\n}\n \nif (EspAlerta) { \nvoid *ui = CurrentUIScene();\nif (ui != NULL) {\nmonoString *nick = get_NickName(PlayerClient);//08\nmonoString *distances = U3DStrFormat(distance);\nShowAssistantText(ui, nick, distances);\n}\n}\n \nif (TeleCar) {\nvoid *_TeleCarTP = get_transform(closestEnemy);\nif (_TeleCarTP != NULL) {\nVector3 TeleCarTP = get_position_Injected(_TeleCarTP) - (get_forward(_TeleCarTP) * 0);\nvoid* LocalCar = VehicleIAmIn(PlayerClient);\nif (LocalCar != NULL) {\nset_position_Injected(get_transform(LocalCar), Vvector3(TeleCarTP.X, TeleCarTP.Y, TeleCarTP.Z));\n}\n}\n}\n \nif (Skill && distance < 100.99 && dirigindo) {\nvoid *_TeleCarTP = get_transform(closestEnemy);\nif (_TeleCarTP != NULL) {\nVector3 TeleCarTP = get_position_Injected(_TeleCarTP) - (get_forward(_TeleCarTP) * 0);\nvoid* LocalCar = VehicleIAmIn(PlayerClient);\nif (LocalCar != NULL) {\nset_position_Injected(get_transform(LocalCar), Vvector3(TeleCarTP.X, TeleCarTP.Y + 2.0, TeleCarTP.Z));\n}\n}\n}\n \nif (TelePro && distance < 600.99 && PlayerClient) {\nvoid *_TeleKillTP = get_transform(closestEnemy);\nif (_TeleKillTP != NULL) {\nVector3 TeleKillTP = get_position_Injected(_TeleKillTP) -(get_forward(_TeleKillTP) * 0);\nset_position_Injected(get_transform(PlayerClient),Vvector3(TeleKillTP.X, TeleKillTP.Y, TeleKillTP.Z ));\n}\n}\n \nif (TelePro2 && distance < 600.99 && PlayerClient) {\nvoid *_TeleKillTP = get_transform(closestEnemy);\nif (_TeleKillTP != NULL) {\nVector3 TeleKillTP = get_position_Injected(_TeleKillTP) -(get_forward(_TeleKillTP) * 0);\nset_position_Injected(get_transform(PlayerClient),Vvector3(TeleKillTP.X, TeleKillTP.Y + 1.0, TeleKillTP.Z ));\n}\n}\n\n\nif(EspGrenade) {\n//if(Visible_Check(closestEnemy)){\nGrenadeLine_DrawLine(Grenade2, LocalPlayerPos, LocalPlayerPos, Vector3(0,1,0) * 0.1);\n((void (*)(void *, Color))getRealOffset(address.set_startColor))(Render2, Color::Red());\n((void (*)(void *, Color))getRealOffset(address.set_endColor))(Render2, Color::Red());\nif (Render2) {\nLineRenderer_Set_PositionCount(Render2, 0x2); \nLineRenderer_SetPosition(Render2, 0, LocalPlayerPos);\nLineRenderer_SetPosition(Render2, 1, PlayerPos);\n}\n}\n\n\n \nif (scope && AimScope) {\nSetAimRotation(PlayerClient, PlayerLook);//09\n}\nif (firing && AimFire) {\nSetAimRotation(PlayerClient, PlayerLook);//10\n}\n}\n}\n}\n}\nUpdate(gamestartup);\n}\n//}\n\nvoid _FlyW(void * _this){\nif (_this) {\nif (StartMenu) {\nvoid *Match = CurrentMatch();\nif (Match) {\nvoid *LocalPlayer = *(void **) ((long) Match + 0x10);\nif (LocalPlayer != NULL) {\nif (FlyHack > 0) {\nbool StopCatapult = false;\nif (IsCatapultFalling(LocalPlayer)) {\nif (!StopCatapult) {\nStopCatapult = true;\nOnStopCatapultFalling(LocalPlayer);\n}\n} else {\nStopCatapult = false;\n}\nif (FlyHack > 0 || Flyspeed > 0) {\nvoid *MyPhsXData = get_MyPhsXData(LocalPlayer);\nif (FlyHack != 0 || Flyspeed != 0) {\nfloat altura;\nfloat speed;\nif (IsFiring(LocalPlayer) || get_IsSighting(LocalPlayer)){\naltura = (float)FlyHack/25;\nspeed = Flyspeed/1000;\n} else {\nif (FlyHack == 1 || Flyspeed == 0) {\naltura = (float)FlyHack/25;\nspeed = Flyspeed/1000;\n} else {\naltura = (float)FlyHack/25;\nspeed = Flyspeed/1000;\n}\n}\n*(float *) ((long) MyPhsXData + address.PetSkillCDEvt) = altura;//0x28\n*(float *) ((long) MyPhsXData + address.HudPlayerSkillBrightAnimEvt) = speed;//0x2c\n}\nif(HackFly) {\nVector3 SalvarPosicao = get_position_Injected(get_transform(LocalPlayer));\nVector3 FlyCamera = get_position_Injected(get_transform(LocalPlayer)) + (get_forward(get_transform(get_main())) * Flyspeed/1000);\nif (IsFiring(LocalPlayer) || get_IsSighting(LocalPlayer)) {\nset_position_Injected(get_transform(LocalPlayer), Vvector3(TFPosX, TFPosY, TFPosZ));\n} else {\nTFPosY = SalvarPosicao.Y;\nTFPosZ = SalvarPosicao.Z;\nTFPosX = SalvarPosicao.X;\nif (FlyHack == 1) TFPosY += FlyHack/25;\nset_position_Injected(get_transform(LocalPlayer), Vvector3(FlyCamera.X, SalvarPosicao.Y, FlyCamera.Z));\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\nvoid(*UpdateFly)(void *_this);\nvoid(_UpdateFly)(void *_this) {\nif (_this == nullptr)\nreturn;\n_FlyW(_this);\nUpdateFly(_this);\n}\n\nint (*orig_GetPhysXPose)(void*_this);\nint hook_GetPhysXPose(void*_this) {\nif (_this != NULL) {\nif (StartMenu) {\nif(FlyHack > 0 || Flyspeed > 0) {\nreturn 10;//10\n// } else if(Jump > 0 || Speed > 0) {\n//return 2;\n} \n}\nreturn orig_GetPhysXPose(_this);\n}\n}\n\nint (*orig_GetPhysXPoseNEW)(void*_this);\nint hook_GetPhysXPoseNEW(void*_this){\nif (_this != NULL) {\nif (StartMenu) {\nif(FlyHack > 0 || Flyspeed > 0) {\nreturn 12;//12\n}\n}\nreturn orig_GetPhysXPoseNEW(_this);\n}\n}\n\nbool (*orig_IsIgnoreHighFalling)(void *_this);\nbool hook_IsIgnoreHighFalling(void *_this) {\nif (_this != NULL){\nif (StartMenu) {\nif(FlyHack > 0 || Flyspeed > 0) {\nreturn true;\n}\nreturn orig_IsIgnoreHighFalling(_this);\n}\n}\n}\n\nbool (*orig_get_IsPoseFallingHigh)(void *_this);\nbool hook_IsPoseFallingHigh(void *_this) {\nif (_this != NULL){\nif (StartMenu) {\nif(FlyHack > 0) {\nreturn true;\n}\nreturn orig_get_IsPoseFallingHigh(_this);\n}\n}\n}\n\nbool (*OnStopCatapultFalling_)(void* _this);\nbool _OnStopCatapultFalling(void* _this) {\nif (_this != NULL) {\nif (StartMenu) {\nif(Flyspeed > 0) {\nreturn true;\n}\nreturn OnStopCatapultFalling_(_this);\n}\n}\n}\n\nint (*GetPhysXState2)(void*_this, int value);\nint _GetPhysXState2(void*_this, int value){\nif (_this != NULL) {\nif (StartMenu) {\nif(FlyHack > 0) {\nreturn 11;\n} else if(HackBoard) {\nreturn false;\n}\n}\nreturn GetPhysXState2(_this, value);\n}\n}\n\nint (*GetPhysXState)(void*_this, int value);\nint _GetPhysXState(void*_this, int value){\nif (_this != NULL) {\nif (StartMenu) {\nif(TelePro) {\nreturn 2;//2\n} else if(HackBoard2) {\nreturn 13;//13\n} \n}\nreturn GetPhysXState(_this, value);\n}\n}\n\nvoid (*SpeedCar)(void *updatedoflyfds);\nvoid _SpeedCar(void *updatedoflyfds) {\nif (StartMenu) {\nvoid *Match = CurrentMatch();\nif (Match) {\nvoid* LocalPlayer = GetLocalPlayer2(Match);//4\nif (LocalPlayer != NULL) {\nVector3 MountCarro = get_position_Injected(get_transform(LocalPlayer));\nvoid* LocalCarro = VehicleIAmIn(LocalPlayer);\nif (LocalCarro) {\nContolCarro = get_position_Injected(get_transform(LocalCarro)) + (get_forward(get_transform(get_main())) * SpeedFlyCarro/10.0f);\nif (FlyCarroConfig == 0 || !VehicleIAmIn(LocalCarro)) {\nFupdmdCarroY = MountCarro.Y;\nFupdmdCarroZ = MountCarro.Z;\nFupdmdCarroX = MountCarro.X;\n}\nif (FlyCarroConfig > 0) {\nif (get_IsSighting(LocalPlayer) || IsFiring(LocalPlayer)) {\nset_position_Injected(get_transform(LocalCarro), Vvector3(FupdmdCarroX, FupdmdCarroY, FupdmdCarroZ));\n} else if (FlyCarroConfig == 1) {\nFupdmdCarroX = MountCarro.X;\nFupdmdCarroY = MountCarro.Y;\nFupdmdCarroZ = MountCarro.Z;\nif (VehicleIAmIn(LocalPlayer)){\nif (FlyCarroConfig > 2) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.0001f, ContolCarro.Z)); \nif (FlyCarroConfig > 3) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.3f, ContolCarro.Z)); \nif (FlyCarroConfig > 4) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.4f, ContolCarro.Z)); \nif (FlyCarroConfig > 5) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.5f, ContolCarro.Z)); \nif (FlyCarroConfig > 6) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.6f, ContolCarro.Z)); \nif (FlyCarroConfig > 7) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.7f, ContolCarro.Z)); \nif (FlyCarroConfig > 8) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.8f, ContolCarro.Z)); \nif (FlyCarroConfig > 9) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.9f, ContolCarro.Z)); \nif (FlyCarroConfig > 10) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.10f, ContolCarro.Z)); \nif (FlyCarroConfig > 11) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.11f, ContolCarro.Z)); \nif (FlyCarroConfig > 12) set_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y + 000.12f, ContolCarro.Z)); \nif (SpeedFlyCarro > 0) {\nif (!get_IsSighting(LocalPlayer) || !IsFiring(LocalPlayer))\nset_position_Injected(get_transform(LocalCarro), Vvector3(ContolCarro.X, MountCarro.Y, ContolCarro.Z));\n}\n} else if (FlyCarroConfig > 1) {\nFupdmdCarroX = MountCarro.X;\nFupdmdCarroY = MountCarro.Y;\nFupdmdCarroZ = MountCarro.Z;\nif (FlyCarroConfig == 2) FupdmdCarroY += 000.0001f;\nif (FlyCarroConfig == 3) FupdmdCarroY += 000.3f;\nif (FlyCarroConfig == 4) FupdmdCarroY += 000.4f;\nif (FlyCarroConfig == 5) FupdmdCarroY += 000.5f;\nif (FlyCarroConfig == 6) FupdmdCarroY += 000.6f;\nif (FlyCarroConfig == 7) FupdmdCarroY += 000.7f;\nif (FlyCarroConfig == 8) FupdmdCarroY += 000.8f;\nif (FlyCarroConfig == 9) FupdmdCarroY += 000.9f;\nif (FlyCarroConfig == 10) FupdmdCarroY += 000.10f;\nif (FlyCarroConfig == 11) FupdmdCarroY += 000.11f;\nif (FlyCarroConfig == 12) FupdmdCarroY += 000.12f;\nset_position_Injected(get_transform(LocalCarro), Vvector3(MountCarro.X, FupdmdCarroY, MountCarro.Z)); \n}\n}\n}\n}\nSpeedCar(updatedoflyfds);\n}\n}\n}\n}\n\nbool (*orig_get_InFallingState)(void *_this);\nbool get_InFallingState(void *_this) {\nif (_this != NULL){\nif (StartMenu) {\nreturn false;\n}\nreturn orig_get_InFallingState(_this);\n}\n}\n \nbool (*switchbellara)(void* _this, int value);\nbool _SwitchFast(void* _this, int value){\nif (_this != NULL){\nif (StartMenu) {\nreturn false;\n}\n}\nreturn switchbellara(_this, value);\n}\n\nbool (*Ghost)(void* _this, int value);\nbool _Ghost(void* _this, int value){\nif (_this != NULL){\nif (StartMenu) {\nif (GhostHack){\nreturn false;\n}\n}\nreturn Ghost(_this, value);\n}\n}\n\nfloat (*GetSpecialRunJumpScale)(void * _this);\nfloat _GetSpecialRunJumpScale(void * _this) {\nif (_this != NULL) {\nif (StartMenu) {\nif(Jump == 1) {\nreturn 1.1;\n} else if(Jump == 2) {\nreturn 1.2;\n} else if(Jump == 3) {\nreturn 1.4;\n} else if(Jump == 4) {\nreturn 1.8;\n} else if(Jump == 5) {\nreturn 2.3;\n} \n}\nreturn GetSpecialRunJumpScale(_this);\n}\n}\n\nfloat (*GetSpecialRunSpeedScale)(void * _this);\nfloat _GetSpecialRunSpeedScale(void * _this) {\nif (_this != NULL) {\nif (StartMenu) {\nif(Speed == 1) {\nreturn 1.8;\n} else if(Speed == 2) {\n return 2.8;\n} else if(Speed == 3) {\nreturn 4.8;\n} else if(Speed == 4) {\nreturn 8.8;\n} else if(Speed == 5) {\nreturn 88;\n} \n}\nreturn GetSpecialRunSpeedScale(_this);\n}\n}\n\nvoid *(*orig_Vehicle)(Vector3 pVehicle);\nvoid *hook_Vehicle(Vector3 pVehicle) {\nif (Flycar >= 0 || Undercar >= 0) {\nvoid * vehicle = GetVehicle(CurrentMatch());\nif (vehicle != nullptr) {\nif (StartMenu) {\npVehicle.X;\npVehicle.Y = pVehicle.Y + Flycar/100;\npVehicle.Y = pVehicle.Y - Undercar/10;\npVehicle.Z;\nreturn orig_Vehicle(pVehicle);\n}\n}\nreturn orig_Vehicle(pVehicle);\n}\n}\n\nvoid (*LateUpdate)(void *componentPlayer);\nvoid *playerlate = NULL;\nvoid *get_Player(void *player){\nplayerlate = player;\nreturn playerlate;\n}\n\nvoid *fakeEnemy;\nvoid _LateUpdate(void *player){\nif (player != NULL) {\nif(StartMenu) {\nvoid *current_Match = CurrentMatch();\nif (current_Match) {\nvoid* local_player = GetLocalPlayer2(current_Match);\nif (local_player) { \nif (!isReady()) {\nmonoDictionary<uint8_t *, void **> *players = *(monoDictionary<uint8_t *, void **> **) ((long) current_Match + address.Dictionary);\nfor (int u = 0; u < players->getNumValues(); u++) {\nvoid *closestEnemy = players->getValues()[u];\nif (closestEnemy && IsVisible(closestEnemy) && !get_IsDieing(closestEnemy) && !IsLocalTeammate(closestEnemy)) {\n \nVector3 EnemyLocation = GetHeadPosition(closestEnemy);\nVector3 CenterWS = GetAttackableCenterWS(local_player);\n\n\nif(EspFire2Azul) {\nvoid *imo = get_imo(local_player);\nif (imo != NULL) {\nif (get_IsDieing(closestEnemy)){\nset_esp(imo, CenterWS, EnemyLocation);\n}else{\nset_esp2(imo, CenterWS, EnemyLocation);\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nget_Player(player);\nLateUpdate(player);\n}\n\nstatic bool isEspReady(){\nreturn false;\n}\n\nvoid DrawESP(ESP esp, int screenWidth, int screenHeight) {\n\nif(crosshair) {\nesp.DrawCrosshair( Color(EspColor), Vector3(screenWidth / 2, screenHeight/2), 80);\n}\n\nesp.DrawCustomColor(Color::Red(),\nVector2(screenWidth / 2 - screenHeight / 6, screenHeight / 16),\nVector2(screenWidth / 2 + screenHeight / 6, screenHeight / 10.1));\nesp.DrawCustomText(Color::Black(), 0.6f, (\"DEXX-TER\"),\nVector3(screenWidth / 2, screenHeight / 11), 30);\n \n//if(ActivateAimbot) {\nif(ActivateEsp) {\nfloat maxTexto = Tamano;\n \nvoid *Amjad = playerlate;\nif (Amjad != nullptr) {\nvoid *current_Match = CurrentMatch();\nif (current_Match) {\nvoid* local_player = GetLocalPlayer2(current_Match);\nif (local_player) { \nif (!isEspReady()) {\nmonoDictionary<uint8_t *, void **> *players = *(monoDictionary<uint8_t*, void **> **)((long)current_Match + address.Dictionary);\nvoid *camera = get_main(); \nif (players != nullptr && camera != nullptr) { \nfor(int u = 0; u < players->getNumValues(); u++) {\nvoid* closestEnemy = players->getValues()[u];\nif (closestEnemy && IsVisible(closestEnemy) && !IsLocalTeammate(closestEnemy) && get_MaxHP(closestEnemy)) {\n \n Vector3 PositionHead = WorldToScreenPoint(camera, GetHeadPosition(closestEnemy));\n Vector3 GetHead = Vector3((screenWidth - (screenWidth - PositionHead.X - EspKanan + EspKiri)), screenHeight - PositionHead.Y - EspAtas + EspBawah);\n if (PositionHead.Z < -0) continue;\n \n Vector3 PositionToe = WorldToScreenPoint(camera, GetToePosition(closestEnemy));\n Vector3 GetToe = Vector3((screenWidth - (screenWidth - PositionToe.X - EspKanan + EspKiri)), screenHeight - PositionToe.Y - EspAtas + EspBawah);\n if (PositionToe.Z < -0) continue; \n \n Vector3 PositionHip = WorldToScreenPoint(camera, GetHipPosition(closestEnemy)); \n Vector3 GetHip = Vector3((screenWidth - (screenWidth - PositionHip.X - EspKanan + EspKiri)), screenHeight - PositionHip.Y - EspAtas + EspBawah);\n if (PositionHip.Z < -0) continue;\n \n Vector3 RShoulder = WorldToScreenPoint(camera,GetRShoulderPosition(closestEnemy));\n if (RShoulder.Z < -0) continue;\n \n Vector3 LShoulder = WorldToScreenPoint(camera,GetLShoulderPosition(closestEnemy));\n if (LShoulder.Z < -0) continue;\n \n Vector3 EnemyLocation = GetHeadPosition(closestEnemy);\n Vector3 CenterWS = GetAttackableCenterWS(local_player); \n float distance = Vector3::Distance(CenterWS, EnemyLocation);\n bool caido = get_IsDieing(closestEnemy);\n \n Vector3 End = PositionHead;\n Vector3 End2 = PositionToe;\n \n float Tamanho = 0.0f;\n float Distance2 = Vector3::Distance(GetHeadPosition(local_player), GetHeadPosition(closestEnemy));\n if (Distance2 > 15.0f) {\n Tamanho = 15.0f;\n } else if (Distance2 > 25.0f) {\n Tamanho = 0.0f;\n }\n \n float boxHeight = ((screenHeight - End2.Y) - (screenHeight - End.Y));\n float boxWidth = static_cast<float>( ((screenWidth - RShoulder.X * 0.995) - (screenWidth - LShoulder.X * 1.005)) * 1.5);\n Rect PlayerRect(screenWidth - (screenWidth - (End2.X - (boxWidth / 2) - EspKiri + EspKanan)), (screenHeight - End.Y - EspAtas + EspBawah), boxWidth, boxHeight);\n float boxHeight2 = ((screenHeight - End.Y) - (screenHeight - End2.Y));\n //Rect PlayerRect2(screenWidth - (screenWidth - (End.X - (boxWidth / 2) - EspKiri + EspKanan)), (screenHeight - End2.Y - EspAtas + EspBawah), boxWidth, boxHeight2);\n \n Rect PlayerRect2(End.X - (boxWidth / 2), (screenHeight - End.Y - 10.0f), boxWidth, boxHeight + Tamanho);\n \n bool ind = *(bool*)((uintptr_t)closestEnemy + address.IsClientBot);\n if (ind) {\n indetifiq = \"[__BOT__]\";\n } else {\n indetifiq = \"[__PLAYER__]\";\n }\n \n char dstc[50]; \n sprintf(dstc, \"[%.2f m]\", distance);\n std::string dist; \n dist = dstc;\n \n int Health = get_CurHP(closestEnemy);\n char Hps[128] = {};\n sprintf(Hps, \"[HP : %d]\", Health);\n std::string vida;\n vida = Hps;\n std::string caidos;\n caidos =\"[Fallen]\";\n std::string nulls;\n nulls =\"\";\n \n \n if(isPlayerLine) {\n if(caido && EspCaidos) {\n esp.DrawLine(Color(CaidoColor), 1.5, Vector3((screenWidth / 2), screenHeight / 16.9f), Vector3((screenWidth - (screenWidth - PositionHead.X)), (screenHeight - PositionHead.Y)));\n } else {\n esp.DrawLine(EspColor, 1.5, Vector3((screenWidth / 2), screenHeight / 16.9f), Vector3((screenWidth - (screenWidth - PositionHead.X)), (screenHeight - PositionHead.Y)));\n }\n }\n \n \n if(espFromCross) {\n if(caido && EspCaidos) {\n esp.DrawLine(Color(CaidoColor), 1.5, Vector3((screenWidth / 2), (screenHeight / 2)), Vector3((screenWidth - (screenWidth - PositionHead.X)), (screenHeight - PositionHead.Y - 8.0f)));\n } else {\n esp.DrawLine(EspColor, 1.5, Vector3((screenWidth / 2), (screenHeight / 2)), Vector3((screenWidth - (screenWidth - PositionHead.X)), (screenHeight - PositionHead.Y - 8.0f)));\n }\n }\n \n \n if(isPlayerBox) {\n if(caido && EspCaidos) {\n esp.DrawBox(Color(CaidoColor), 1.5, PlayerRect2);\n } else {\n esp.DrawBox(EspColor, 1.5, PlayerRect2);\n }\n }\n \n monoString* nick = get_NickName(closestEnemy);\n std::string names;\n if(nick != NULL) {\n int nick_Len = nick ->getLength();\n for(int i = 0; i < nick_Len; i++) {\n char data = get_Chars(nick, i);\n names += isascii(data) ? data : data;\n }\n }\n std::string dnames;\n dnames =\"[\"+ names+\"]\";\n \n if(isPlayerIdent && isPlayerName){\n if(ind){\n dnames =\"[\"+ names+\"]\";\n }else{\n dnames =\"[\"+ names+\"]\";\n }\n }\n \n if(isPlayerName) {\n if(caido && EspCaidos) {\n esp.DrawText(Color(CaidoColor), 0.6f,\n nulls.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }else{\n esp.DrawText(Color(EspColor), 0.6f,\n dnames.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }\n }\n \n if(isPlayerIdent) {\n if(caido && EspCaidos) {\n if(isPlayerName){\n esp.DrawText(Color(CaidoColor), 0.6f,\n nulls.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }else{\n esp.DrawText(Color(CaidoColor), 0.6f,\n nulls.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }\n \n } else {\n if(isPlayerName){\n esp.DrawText(Color(EspColor), 0.6f,\n dnames.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }else{\n esp.DrawText(Color(EspColor), 0.6f,\n indetifiq.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y - 12.0f),\n maxTexto);\n }\n }\n }\n \n if(isPlayerHealth && isPlayerDist){\n dist =dist + \" - \" + vida;\n }\n \n if(isPlayerDist) {\n if(caido && EspCaidos) {\n esp.DrawText(Color(CaidoColor), 0.6, caidos.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2),\n PlayerRect.y + PlayerRect.height + 12.5f), maxTexto);\n }else{\n esp.DrawText(Color(EspColor), 0.6, dist.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2),\n PlayerRect.y + PlayerRect.height + 12.5f), maxTexto);\n }\n }\n \n if(isPlayerHealth) {\n if(caido && EspCaidos) {\n if(isPlayerDist){\n esp.DrawText(Color(CaidoColor), 0.6f,\n caidos.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y + PlayerRect.height + 12.5f),\n maxTexto);\n }else{\n esp.DrawText(Color(CaidoColor), 0.6f,\n caidos.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y + PlayerRect.height + 12.5f),\n maxTexto);\n }\n } else {\n if(isPlayerDist){\n esp.DrawText(Color(EspColor), 0.6f,\n dist.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y + PlayerRect.height + 12.5f),\n maxTexto);\n }else{\n esp.DrawText(Color(EspColor), 0.6f,\n vida.c_str(),\n Vector3(PlayerRect.x + (PlayerRect.width / 2), PlayerRect.y + PlayerRect.height + 12.5f),\n maxTexto);\n }\n }\n }\n }\n }\n }\n }\n }\n }\n }\n }\n }\n \n\nbool(*orig_Test)(void* _this); \nbool _Test(void* _this) { \nreturn false;\nreturn orig_Test(_this);\n}\n\nvoid(*MatchMaking)(void* _this); \nvoid _MatchMaking(void* _this) { \nreturn;\nreturn MatchMaking(_this);\n}\n\nbool(*FixGame)(void* _this);\nbool _FixGame(void* _this) {\nif (_this != NULL) {\nreturn true; \n}\n}\n\nbool(*GetBlackList)(void* _this); \nbool _GetBlackList(void* _this) {\nreturn false;\n}\n\nbool(*GetBlack)(void* _this); \nbool _GetBlack(void* _this) {\nreturn true;\n}\n\nvoid(*AntBan)(void* _this);\nvoid _AntBan(void* _this){\nif (AntBan != NULL) {\nreturn;\n}\nreturn AntBan(_this);\n}\n\nvoid(*ChanBypass)(void* _this);\nvoid _ChanBypass(void* _this){\nreturn;\nreturn ChanBypass(_this);\n}\n\nbool(*Filedone)(void* _this);\nbool _Filedone(void* _this){\nreturn false;\n}\n\nbool(*AntiCrash)(void*_this, int value);\nbool _AntiCrash(void*_this, int value){\nif (_this != NULL) {\nreturn 10000000;\nreturn AntiCrash(_this, value);\n}\n}\n\nbool(*Bypass)(void* _this);\nbool _Bypass(void* _this){\nreturn false;\n}\n\nvoid(*Yuim)(void* _this); \nvoid _Yuim(void* _this) { \nreturn;\nreturn Yuim(_this);\n}\n\nvoid *hack_thread(void *) {\nProcMap il2cppMap;\ndo {\nil2cppMap = KittyMemory::getLibraryMap(\"libil2cpp.so\");\nsleep(1);\n} while (!il2cppMap.isValid());\n\n\n/**/FastReload = MemoryPatch(\"libil2cpp.so\",0x18062e0,\"\\x16\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//ok\n\n\n/**/NoScope = MemoryPatch(\"libil2cpp.so\",0x14fd8b0,\"\\x00\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//ok\n// public virtual Boolean IsSightingUIAvailable() { }\n\n/**/FreeWater = MemoryPatch(\"libil2cpp.so\",0x149db48,\"\\x06\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//ok\n// public EPhysXState GetPhysXState() { }\n\n/**/AutoJump = MemoryPatch(\"libil2cpp.so\",0x46316fc,\"\\x01\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//ok\n// public override EPlayerRequestType GetRequestType() { }\n\n/**/DriveSpeed = MemoryPatch::createWithHex(\"libil2cpp.so\",0x2b1ba8c,\"C8 02 44 E3 1E FF 2F E1\");//ok\n// public Single get_DriveSpeedScale() { }\n\n/**/WhiteBody1 = MemoryPatch(\"libil2cpp.so\", 0x10ae4cc, \"\\x01\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);\n/**/WhiteBody2 = MemoryPatch(\"libil2cpp.so\", 0x442cdf0, \"\\x00\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);\n\n/**/Blackbody = MemoryPatch::createWithHex(\"libil2cpp.so\", 0x5ab1b78, \"01 00 A0 E3 1E FF 2F E1\");//ok\n/**/Ultimateammo = MemoryPatch::createWithHex(\"libil2cpp.so\", 0x1b86eb4, \"01 00 A0 E3 1E FF 2F E1\");//ok\n/**/DiamondHack = MemoryPatch::createWithHex(\"libil2cpp.so\", 0x3471100, \"99 05 A0 E3 1E FF 2F E1\");//ok\n/**/GoldHack = MemoryPatch::createWithHex(\"libil2cpp.so\", 0x34710f0, \"99 05 A0 E3 1E FF 2F E1\");//ok\n\n/**/ResetGuest = MemoryPatch::createWithHex(\"libil2cpp.so\", 0x5316084, \"01 00 A0 E3 1E FF 2F E1\");//ok\n\n/**/GetVBadge = MemoryPatch(\"libil2cpp.so\",0x47706e4,\"\\x01\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//ok\n\n\n\n// AimBot\nHOOK_LIB(0x14cce98, _Update, Update);//ok\nHOOK_LIB(0x14dee2c, _LateUpdate, LateUpdate);//ok\n\nHOOK_LIB(0x2ab428c, _UpdateLine, UpdateLine);//ok\nHOOK_LIB(0x2ab51f0, _UpdateLine, UpdateLine);// private Void Update() { }\n\n// Speed Jump\nHOOK_LIB(0x2b1918c, _GetSpecialRunSpeedScale, GetSpecialRunSpeedScale);//\nHOOK_LIB(0x1557ed8, _GetSpecialRunJumpScale, GetSpecialRunJumpScale);//\n\n// Drive Skill\nHOOK_LIB(0x6945d2c, hook_Vehicle, orig_Vehicle);//\nHOOK_LIB(0x6d5d6a4, _SpeedCar, SpeedCar);//\n// private Void LateUpdate() { }   |  Class: UIScrollView\n\n\n//HOOK_LIB(address.TakeDamage, hook_TakeDamage1, orig_TakeDamage1);\n\n// Ghost Guest\nHOOK_LIB(0x1f4cf40, _Ghost, Ghost);// private Boolean NeedSendMessage(Player player) { }\n\n// FlyPlayer\nHOOK_LIB(address.UpdateFly, _UpdateFly, UpdateFly);//\nHOOK_LIB(address.orig_GetPhysXPoseNEW, hook_GetPhysXPoseNEW, orig_GetPhysXPoseNEW);//\nHOOK_LIB(address.orig_GetPhysXPose, hook_GetPhysXPose, orig_GetPhysXPose);//\nHOOK_LIB(address.GetPhysXState, _GetPhysXState, GetPhysXState);//\nHOOK_LIB(address.GetPhysXState2, _GetPhysXState2, GetPhysXState2);\nHOOK_LIB(address.orig_get_IsPoseFallingHigh, hook_IsPoseFallingHigh, orig_get_IsPoseFallingHigh);\nHOOK_LIB(address.orig_IsIgnoreHighFalling, hook_IsIgnoreHighFalling, orig_IsIgnoreHighFalling);\nHOOK_LIB(address.OnStopCatapultFalling, _OnStopCatapultFalling, OnStopCatapultFalling_);\n\n// AimKill\n//HOOK_LIB(0x188c654, DamageInfoHook, DamageInfo);\nHOOK_LIB(address.orig_get_InFallingState, get_InFallingState, orig_get_InFallingState);//\nHOOK_LIB(address.switchbellara, _SwitchFast, switchbellara);//\n\nDamage = MemoryPatch(\"libil2cpp.so\", 0x19e4050,\"\\x01\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\",8);\nAimMovement = MemoryPatch(\"libil2cpp.so\",0x14eb2d4, \"\\x01\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);\n/**/Medikit = MemoryPatch(\"libil2cpp.so\",0x3e5e3c4,\"\\x00\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//\n/**/Medikit2 = MemoryPatch(\"libil2cpp.so\",0x146db54,\"\\x00\\x00\\xA0\\xE3\\x1E\\xFF\\x2F\\xE1\", 8);//\n\n/*1.105*HOOK_LIB(0x1425220, _ChanBypass, ChanBypass);//public static void StartLogGameLag() { }\n/*1.105*HOOK_LIB(0x1425bcc, _ChanBypass, ChanBypass);//public static void SendGameLagLog() { }\n\n/// FixGame\n*\nMemoryPatch(\"libil2cpp.so\", 0x15d4c08, \"00 00 A0 E3 1E FF 2F E1\", 4).Modify(); //[1.94] public bool IsBypassed(Uri host) { }\n\n\tMemoryPatch(\"libil2cpp.so\", 0x1f7a104, \"40 0F 43 E3 1E FF 2F E1\", 4).Modify(); //[1.94] public bool IsBypassed(Uri host) { }\n\tMemoryPatch(\"libil2cpp.so\", 0x17cd2a8, \"00 00 00 00\", 4).Modify(); //[1.94] public bool IsBypassed(Uri host) { }\n\t\n\t\n\t\n   MemoryPatch::createWithHex(\"libil2cpp.so\", 0x56c3b6c + 116, \"00 F0 20 E3\", 4).Modify();\n    MemoryPatch::createWithHex(\"libil2cpp.so\", 0x5111c10 + 136, \"00 F0 20 E3\", 4).Modify();\n\t\t\n    MemoryPatch::createWithHex(\"libil2cpp.so\", 0X3450EB8 + 116, \"00 F0 20 E3\", 4).Modify();\n    MemoryPatch::createWithHex(\"libil2cpp.so\", 0x4886848 + 136, \"00 F0 20 E3\", 4).Modify();\n    \n    \n    \n\t\nMSHookFunction((void *)getRealOffset(0x179dab8), (void *)_Test, (void **)&orig_Test); // private Void DetectAndroidApplications() { }\nMSHookFunction((void *)getRealOffset(0x6025d98), (void *)_MatchMaking, (void **)&MatchMaking); //public static bool IsInstanceOf(IntPtr obj, IntPtr clazz) { }\nMSHookFunction((void *)getRealOffset(0x179acb8), (void *)_Test, (void **)&orig_Test); // private Void ProcessANOGGP(LoginRes loginRes, (void **)&MajorLoginRes majorRes) { }\nMSHookFunction((void *)getRealOffset(0x521f4f0), (void *)_Test, (void **)&orig_Test); // public static Byte[] IIHDEHLHKEC(String LODDOINFPPA) { }\nMSHookFunction((void *)getRealOffset(0x46f4574), (void *)_Test, (void **)&orig_Test);// public static Void DPLMGOJKKCM(Int32 EFDAAJBHMPD) { }\nMSHookFunction((void *)getRealOffset(0x510cc1c), (void *)_Test, (void **)&orig_Test); // public static Byte[] LHAJPJBCOLC(String IDNEFEOPGIF) { }\nMSHookFunction((void *)getRealOffset(0x510c0c0), (void *)_Test, (void **)&orig_Test); // public static void CCNEAFOPMIH(string DJKDKPMGKGH, string[] CLFFPBABFLP) { }\n\nMSHookFunction((void *)getRealOffset(0x46f42d4), (void *)_Bypass, (void **)&Bypass); // public static void CCNEAFOPMIH(string DJKDKPMGKGH, string[] CLFFPBABFLP) { }\n\n    MSHookFunction((void *)getRealOffset(0x46f4578), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x1105908), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x510bf70), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x510c0c0), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x179dab8), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x347ac80), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x1598910), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x1598ac8), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x159d224), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x1589914), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x431c734), (void *)_AntiCrash, (void **)&AntiCrash);\n    \n    MSHookFunction((void *)getRealOffset(0x4aaae48), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x19e33a8), (void *)_AntiCrash, (void **)&AntiCrash);\n    MSHookFunction((void *)getRealOffset(0x19e3860), (void *)_AntiCrash, (void **)&AntiCrash);\n    \n    \nMemoryPatch::createWithHex(\"libil2cpp.so\", 0x46f4578, \"00 00 A0 E3 1E FF 2F E1\").Modify();\nMemoryPatch::createWithHex(\"libil2cpp.so\", 0x1105908, \"00 00 A0 E3 1E FF 2F E1\").Modify();\nMemoryPatch::createWithHex(\"libil2cpp.so\", 0x510bf70, \"00 00 A0 E3 1E FF 2F E1\").Modify();\nMemoryPatch::createWithHex(\"libil2cpp.so\", 0x510c0c0, \"00 00 A0 E3 1E FF 2F E1\").Modify();\n\n\n// Fix band team 4 Done\nMSHookFunction((void *)getRealOffset(0x1588af4), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x1589c7c), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x158a1b0), (void *)_Yuim, (void **)&Yuim); \nMSHookFunction((void *)getRealOffset(0x1598910), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x1598c40), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x15b6dc8), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x15eb3e4), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x3938cd8), (void *)_Yuim, (void **)&Yuim); \nMSHookFunction((void *)getRealOffset(0x3939970), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x522a2c4), (void *)_Yuim, (void **)&Yuim);\nMSHookFunction((void *)getRealOffset(0x522a41c), (void *)_Yuim, (void **)&Yuim); \nMSHookFunction((void *)getRealOffset(0x522a6fc), (void *)_Yuim, (void **)&Yuim); \nMSHookFunction((void *)getRealOffset(0x522a798), (void *)_Yuim, (void **)&Yuim);\n\n///_&&&&_&\n\nMSHookFunction((void *)getRealOffset(0x52cd5c0), (void *)_Yuim, (void **)&Yuim);//public Void .ctor() { }\nMSHookFunction((void *)getRealOffset(0x431ef30), (void *)_Yuim, (void **)&Yuim);//private static Void .cctor() { }\nMSHookFunction((void *)getRealOffset(0x431ed98), (void *)_Yuim, (void **)&Yuim);//public Void .ctor() { }\n/*\nMSHookFunction((void *)getRealOffset(0x431ea6c), (void *)_GetBlackList, (void **)&GetBlackList);//public static Int32 ReportUserAudio(String reportUserID, String customData) { }\nMSHookFunction((void *)getRealOffset(0x431e8d4), (void *)_GetBlackList, (void **)&GetBlackList);//public static Int32 SetReportInfo(Int32 nTimeSec, String language) { }\nMSHookFunction((void *)getRealOffset(0x431ca30), (void *)_GetBlackList, (void **)&GetBlackList);//public static Int32 JoinRoom(RoomInfo info) { }\nMSHookFunction((void *)getRealOffset(0x431cbb4), (void *)_GetBlackList, (void **)&GetBlackList);//public static Void OnJoined(String room_id) { }\nMSHookFunction((void *)getRealOffset(0x2eb74b4), (void *)_GetBlackList, (void **)&GetBlackList);//public Void Update(Single gameTime) { }\n\n/*\n\t// RVA: 0x52cd5c0 VA: 0xb7c545c0\n\tpublic Void .ctor() { }\n    \n    \t// RVA: 0x51d8608 VA: 0xb7b5f608\n\tpublic static String EAFJGAEHOGK(Boolean KOPAFJHCIIM) { }\n    \n    \t// RVA: 0x51d8070 VA: 0xb7b5f070\n\tpublic static String DGFDEECPIDP() { }\n    \n    \t// RVA: 0x431ef30 VA: 0xb6ca5f30\n\tprivate static Void .cctor() { }\n    \n    \t// RVA: 0x431ed98 VA: 0xb6ca5d98\n\tpublic static Int32 SetVoiceReciver(String roomId, String userList) { }\n    \n    \t// RVA: 0x431ec04 VA: 0xb6ca5c04\n\tpublic static Void SetUserVolume(String userId, UInt32 volume) { }\n    \n    \t// RVA: 0x431ea6c VA: 0xb6ca5a6c\n\tpublic static Int32 ReportUserAudio(String reportUserID, String customData) { }\n    \n    \t// RVA: 0x431e8d4 VA: 0xb6ca58d4\n\tpublic static Int32 SetReportInfo(Int32 nTimeSec, String language) { }\n    \n    \t// RVA: 0x431e5c0 VA: 0xb6ca55c0\n\tpublic static Int32 MuteTargetPlayer(String player_id, Boolean is_mute) { }\n    \n    \t// RVA: 0x431e440 VA: 0xb6ca5440\n\tpublic static Void EnableVoiceCaptureCallBack(Boolean enable) { }\n    \n    \t// RVA: 0x431e2c8 VA: 0xb6ca52c8\n\tpublic static Void OnUpdate() { }\n    \n    \t// RVA: 0x431de58 VA: 0xb6ca4e58\n\tpublic static Void SetMicAndSpeakerMute(Boolean micro_mute, Boolean speaker_mute) { }\n    \n    \t// RVA: 0x431dcd0 VA: 0xb6ca4cd0\n\tpublic static Boolean IsSameWithCurSpeakerMute(Boolean value) { }\n    \n    \t// RVA: 0x431db48 VA: 0xb6ca4b48\n\tpublic static Boolean IsSameWithCurMicMute(Boolean value) { }\n    \n    \t// RVA: 0x431d9c8 VA: 0xb6ca49c8\n\tpublic static Void SetVolume(UInt32 volume) { }\n    \n    \t// RVA: 0x431d804 VA: 0xb6ca4804\n\tpublic static String ParseErrorCodeName(Int32 error_code) { }\n    \n    \t// RVA: 0x431d640 VA: 0xb6ca4640\n\tpublic static String ParseEventName(Int32 event_id) { }\n    \n    \t// RVA: 0x431d4a8 VA: 0xb6ca44a8\n\tpublic static EGameVoiceEvent ParseEventType(Int32 event_id, String param) { }\n    \n    \t// RVA: 0x431d324 VA: 0xb6ca4324\n\tpublic static Boolean HasError(Int32 error_code) { }\n    \n    \t// RVA: 0x431d1a8 VA: 0xb6ca41a8\n\tpublic static Int32 UnInit() { }\n    \n    \t// RVA: 0x431d030 VA: 0xb6ca4030\n\tpublic static Void SetMicCallback() { }\n    \n    \t// RVA: 0x431ceb0 VA: 0xb6ca3eb0\n\tpublic static Void PauseChannel(Boolean is_pause) { }\n    \n    \t// RVA: 0x431cd34 VA: 0xb6ca3d34\n\tpublic static Int32 LeaveRoom() { }\n    \n    \t// RVA: 0x431cbb4 VA: 0xb6ca3bb4\n\tpublic static Void OnJoined(String room_id) { }\n    \n    \t// RVA: 0x431ca30 VA: 0xb6ca3a30\n\tpublic static Int32 JoinRoom(RoomInfo info) { }\n    \n    \t// RVA: 0x431c8b8 VA: 0xb6ca38b8\n\tpublic static Void OnInited() { }\n    \n    \t// RVA: 0x431c734 VA: 0xb6ca3734\n\tpublic static Int32 Init(String callBack_objectName) { }\n    \n    \t// RVA: 0x431c5b4 VA: 0xb6ca35b4\n\tpublic static Void SetExtraConfig(Object extra_config) { }\n    \n    \t// RVA: 0x431c420 VA: 0xb6ca3420\n\tpublic static Void SetAppkeySecret(String appKey, String appSecret) { }\n    \n    \t// RVA: 0x431c28c VA: 0xb6ca328c\n\tpublic static Void SetRegion(Int32 region_id, String region_name) { }\n    \n    \t// RVA: 0x431c10c VA: 0xb6ca310c\n\tpublic static Void SetGroupEnvironment(String environment) { }\n    \n    \t// RVA: 0x431c04c VA: 0xb6ca304c\n\tpublic static Void SetImpl(IGameVoiceInterface impl) { }\n    \n    \t// RVA: 0x431be7c VA: 0xb6ca2e7c\n\tpublic static GameVoiceImpl_FreeFireVoice get_FreeFireVoiceImpl() { }\n    \n    \t// RVA: 0x4319da4 VA: 0xb6ca0da4\n\tpublic static Int32 setUTData(String utData) { }\n    \n    \t// RVA: 0x2eb74b4 VA: 0xb583e4b4\n\tpublic Void Update(Single gameTime) { }\n    \n    \n    \n    \n    \n\n\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x4b7b2c0), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x488d7d0), (void *)_FixGame, (void **)&FixGame);//ok\n\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x62cbb24), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x579326c), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x5712280), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x5714dcc), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x5714c94), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x60806f4), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x6080148), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x60801f4), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x4acea14), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x1502c30), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x1501d2c), (void *)_FixGame, (void **)&FixGame);//ok\n\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x1705a90), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x1704a94), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x1706ee8), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x545b7f8), (void *)_FixGame, (void **)&FixGame);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x530e9b8), (void *)_FixGame, (void **)&FixGame);//ok\n\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x4911d80), (void *)_GetBlackList, (void **)&GetBlackList);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x64a7a40), (void *)_GetBlackList, (void **)&GetBlackList);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x488d920), (void *)_GetBlackList, (void **)&GetBlackList);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x3be2e50), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x3be32f8), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x3be36e8), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x3be3b50), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x47e3020), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x542a8c8), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x176fee0), (void *)_GetBlackList, (void **)&GetBlack);//ok\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x15d3e88), (void *)_GetBlack, (void **)&GetBlack);//ok\n/*MSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x64265c8), (void *)_GetBlackList, (void **)&GetBlack);//\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x6426680), (void *)_GetBlack, (void **)&GetBlack);//\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x6427200), (void *)_AntBan, (void **)&AntBan);//\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x563e820), (void *)_AntBan, (void **)&AntBan);//\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x56c60f4), (void *)_AntBan, (void **)&AntBan);//\nMSHookFunction((void *)AgetAbsoluteAddress(\"libil2cpp.so\", 0x4b7b2b8), (void *)_AntBan, (void **)&AntBan);//ok\n\n\nHOOK_LIB(0x17824a8,_Test, orig_Test); // private Void DetectAndroidApplications() { }\nHOOK_LIB(0x64a7a40,_MatchMaking, MatchMaking); //public static bool IsInstanceOf(IntPtr obj, IntPtr clazz) { }\nHOOK_LIB(0x177f5c4,_Test, orig_Test); // private Void ProcessANOGGP(LoginRes loginRes, MajorLoginRes majorRes) { }\nHOOK_LIB(0x550ddb4,_Test, orig_Test); // public static Byte[] IIHDEHLHKEC(String LODDOINFPPA) { }\n*/\nreturn NULL;\n}\n\nextern \"C\" \nJNIEXPORT void JNICALL\nJava_uk_lgl_modmenu_FloatingModMenuService_DrawOn(JNIEnv *env, jclass type, jobject espView, jobject canvas) {\nespOverlay = ESP(env, espView, canvas);\nif (espOverlay.isValid()){\nDrawESP(espOverlay, espOverlay.getWidth(), espOverlay.getHeight());\n}\n}\n\n\nJNIEXPORT jint JNICALL\nJNI_OnLoad(JavaVM *vm, void *reserved) {\nJNIEnv *globalEnv;\nvm->GetEnv((void **) &globalEnv, JNI_VERSION_1_6);\npthread_t ptid;\npthread_create(&ptid, NULL, hack_thread, NULL);\nreturn JNI_VERSION_1_6;\n}\n","size_bytes":56754},"app/build/gen/uk/lgl/modmenu/BuildConfig.java":{"content":"/** Automatically generated file. DO NOT MODIFY */\npackage uk.lgl.modmenu;\n\npublic final class BuildConfig {\n    public final static boolean DEBUG = true;\n    public final static String APPLICATION_ID = \"uk.lgl.modmenu\";\n    public final static String BUILD_TYPE = \"debug\";\n    public final static long VERSION_CODE = 1;\n    public final static String VERSION_NAME = \"1.0\";\n}","size_bytes":375},"app/build/gen/uk/lgl/modmenu/R.java":{"content":"/* AUTO-GENERATED FILE.  DO NOT MODIFY.\n *\n * This class was automatically generated by the\n * aapt tool from the resource data it found.  It\n * should not be modified by hand.\n */\n\npackage uk.lgl.modmenu;\n\npublic final class R {\n    public static final class attr {\n    }\n    public static final class color {\n        public static final int colorAccent=0x7f050002;\n        public static final int colorPrimary=0x7f050000;\n        public static final int colorPrimaryDark=0x7f050001;\n    }\n    public static final class drawable {\n        public static final int ic_launcher_background=0x7f020000;\n        public static final int ic_launcher_foreground=0x7f020001;\n        public static final int ic_launcher_foreground_1=0x7f020002;\n    }\n    public static final class layout {\n        public static final int activity_main=0x7f040000;\n    }\n    public static final class mipmap {\n        public static final int ic_launcher=0x7f030000;\n        public static final int ic_launcher_round=0x7f030001;\n    }\n    public static final class string {\n        public static final int app_name=0x7f060000;\n    }\n    public static final class style {\n        public static final int AppTheme=0x7f070000;\n    }\n}\n","size_bytes":1204},"app/src/main/jni/src/KittyMemory/KittyMemory.cpp":{"content":"//\n//  KittyMemory.cpp\n//\n//  Created by MJ (Ruit) on 1/1/19.\n//\n\n#include \"KittyMemory.h\"\n\nusing KittyMemory::Memory_Status;\nusing KittyMemory::ProcMap;\n\n\nstruct mapsCache {\n    std::string identifier;\n    ProcMap map;\n};\n\nstatic std::vector<mapsCache> __mapsCache;\nstatic ProcMap findMapInCache(std::string id){\n    ProcMap ret;\n    for(int i = 0; i < __mapsCache.size(); i++){\n        if(__mapsCache[i].identifier.compare(id) == 0){\n            ret = __mapsCache[i].map;\n            break;\n        }\n    }\n    return ret;\n}\n\n\nbool KittyMemory::ProtectAddr(void *addr, size_t length, int protection) {\n   uintptr_t pageStart = _PAGE_START_OF_(addr);\n   uintptr_t pageLen   = _PAGE_LEN_OF_(addr, length);\n   return (\n     mprotect(reinterpret_cast<void *>(pageStart), pageLen, protection) != -1\n );\n}\n\n\nMemory_Status KittyMemory::memWrite(void *addr, const void *buffer, size_t len) {\n    if (addr == NULL)\n        return INV_ADDR;\n\n    if (buffer == NULL)\n        return INV_BUF;\n\n    if (len < 1 || len > INT_MAX)\n        return INV_LEN;\n\n    if (!ProtectAddr(addr, len, _PROT_RWX_))\n        return INV_PROT;\n\n    if (memcpy(addr, buffer, len) != NULL && ProtectAddr(addr, len, _PROT_RX_))\n        return SUCCESS;\n\n    return FAILED;\n}\n\n\nMemory_Status KittyMemory::memRead(void *buffer, const void *addr, size_t len) {\n    if (addr == NULL)\n        return INV_ADDR;\n\n    if (buffer == NULL)\n        return INV_BUF;\n\n    if (len < 1 || len > INT_MAX)\n        return INV_LEN;\n\n    if (memcpy(buffer, addr, len) != NULL)\n        return SUCCESS;\n\n    return FAILED;\n}\n\n\nstd::string KittyMemory::read2HexStr(const void *addr, size_t len) {\n    char temp[len];\n    memset(temp, 0, len);\n\t\n    const size_t bufferLen = len * 2 + 1;\n    char buffer[bufferLen];\n    memset(buffer, 0, bufferLen);\n\n    std::string ret;\n\n    if (memRead(temp, addr, len) != SUCCESS)\n        return ret;\n\n    for (int i = 0; i < len; i++) {\n        sprintf(&buffer[i * 2], \"%02X\", (unsigned char) temp[i]);\n    }\n\n    ret += buffer;\n    return ret;\n}\n\nProcMap KittyMemory::getLibraryMap(const char *libraryName) {\n    ProcMap retMap;\n    char line[512] = {0};\n\n    FILE *fp = fopen(\"/proc/self/maps\", \"rt\");\n    if (fp != NULL) {\n        while (fgets(line, sizeof(line), fp)) {\n            if (strstr(line, libraryName)) {\n                char tmpPerms[5] = {0}, tmpDev[12] = {0}, tmpPathname[444] = {0};\n                // parse a line in maps file\n                // (format) startAddress-endAddress perms offset dev inode pathname\n                sscanf(line, \"%llx-%llx %s %ld %s %d %s\",\n                       (long long unsigned *) &retMap.startAddr,\n                       (long long unsigned *) &retMap.endAddr,\n                       tmpPerms, &retMap.offset, tmpDev, &retMap.inode, tmpPathname);\n\n                retMap.length = (uintptr_t) retMap.endAddr - (uintptr_t) retMap.startAddr;\n                retMap.perms = tmpPerms;\n                retMap.dev = tmpDev;\n                retMap.pathname = tmpPathname;\n\n                break;\n            }\n        }\n        fclose(fp);\n    }\n    return retMap;\n}\n\nuintptr_t KittyMemory::getAbsoluteAddress(const char *libraryName, uintptr_t relativeAddr, bool useCache) {\n    ProcMap libMap;\n\n    if(useCache){\n        libMap = findMapInCache(libraryName);\n        if(libMap.isValid())\n        return (reinterpret_cast<uintptr_t>(libMap.startAddr) + relativeAddr);\n    }\n       \n    libMap = getLibraryMap(libraryName);\n    if (!libMap.isValid())\n        return 0;\n\n    if(useCache){\n        mapsCache cachedMap;\n        cachedMap.identifier = libraryName;\n        cachedMap.map        = libMap;\n        __mapsCache.push_back(cachedMap);\n    }\n\n    return (reinterpret_cast<uintptr_t>(libMap.startAddr) + relativeAddr);\n}\n","size_bytes":3751},"app/src/main/jni/src/KittyMemory/KittyUtils.cpp":{"content":"#include \"KittyUtils.h\"\n\nstatic void xtrim(std::string &hex){\n    if(hex.compare(0, 2, \"0x\") == 0){\n        hex.erase(0, 2);\n    }\n\n    // https://www.techiedelight.com/remove-whitespaces-string-cpp/\n    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c){\n\t\t\t\t\t\t\t\treturn (c == ' ' || c == '\\n' || c == '\\r' ||\n\t\t\t\t\t\t\t\t\t\tc == '\\t' || c == '\\v' || c == '\\f');\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thex.end());\n}\n\n\nbool KittyUtils::validateHexString(std::string &xstr){\n    if(xstr.length() < 2) return false;\n    xtrim(xstr); // first remove spaces\n    if(xstr.length() % 2 != 0) return false;\n    for(size_t i = 0; i < xstr.length(); i++){\n        if(!std::isxdigit((unsigned char)xstr[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// https://tweex.net/post/c-anything-tofrom-a-hex-string/\n#include <sstream>\n#include <iomanip>\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a block of data to a hex string\n*/\nvoid KittyUtils::toHex(\n    void *const data,           //!< Data to convert\n    const size_t dataLength,    //!< Length of the data to convert\n    std::string &dest           //!< Destination string\n    )\n{\n    unsigned char     *byteData = reinterpret_cast<unsigned char*>(data);\n    std::stringstream hexStringStream;\n    \n    hexStringStream << std::hex << std::setfill('0');\n    for(size_t index = 0; index < dataLength; ++index)\n        hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);\n    dest = hexStringStream.str();\n}\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a hex string to a block of data\n*/\nvoid KittyUtils::fromHex(\n    const std::string &in,     //!< Input hex string\n    void *const data           //!< Data store\n    )\n{\n    size_t          length    = in.length();\n    unsigned char   *byteData = reinterpret_cast<unsigned char*>(data);\n    \n    std::stringstream hexStringStream; hexStringStream >> std::hex;\n    for(size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)\n    {\n        // Read out and convert the string two characters at a time\n        const char tmpStr[3] = { in[strIndex++], in[strIndex++], 0 };\n\n        // Reset and fill the string stream\n        hexStringStream.clear();\n        hexStringStream.str(tmpStr);\n\n        // Do the conversion\n        int tmpValue = 0;\n        hexStringStream >> tmpValue;\n        byteData[dataIndex] = static_cast<unsigned char>(tmpValue);\n    }\n}","size_bytes":2461},"app/src/main/jni/src/KittyMemory/MemoryBackup.cpp":{"content":"//\n//  MemoryBackup.cpp\n//\n//  Created by MJ (Ruit) on 4/19/20.\n//\n\n#include \"MemoryBackup.h\"\n\n\nMemoryBackup::MemoryBackup() {\n  _address = 0;\n  _size    = 0;\n  _orig_code.clear();\n}\n\nMemoryBackup::MemoryBackup(const char *libraryName, uintptr_t address, size_t backup_size, bool useMapCache) {\n  MemoryBackup();\n\n  if (libraryName == NULL || address == 0 || backup_size < 1)\n    return;\n\n  _address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n  if(_address == 0) return;\n  \n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\n\nMemoryBackup::MemoryBackup(uintptr_t absolute_address, size_t backup_size) {\n  MemoryBackup();\n\n  if (absolute_address == 0 || backup_size < 1)\n    return;\n\n  _address = absolute_address;\n  \n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\n   MemoryBackup::~MemoryBackup() {\n     // clean up\n     _orig_code.clear();\n   }\n\n\n  bool MemoryBackup::isValid() const {\n    return (_address != 0 && _size > 0\n            && _orig_code.size() == _size);\n  }\n\n  size_t MemoryBackup::get_BackupSize() const{\n    return _size;\n  }\n\n  uintptr_t MemoryBackup::get_TargetAddress() const{\n    return _address;\n  }\n\n  bool MemoryBackup::Restore() {\n    if (!isValid()) return false;\n    return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) == Memory_Status::SUCCESS;\n  }\n\n  std::string MemoryBackup::get_CurrBytes() {\n    if (!isValid()) \n      _hexString = std::string(\"0xInvalid\");\n      else \n      _hexString = KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);\n\n    return _hexString;\n  }\n","size_bytes":1860},"app/src/main/jni/src/KittyMemory/MemoryPatch.cpp":{"content":"//\n//  MemoryPatch.cpp\n//\n//  Created by MJ (Ruit) on 1/1/19.\n//\n\n#include \"MemoryPatch.h\"\n\n\nMemoryPatch::MemoryPatch() {\n  _address = 0;\n  _size    = 0;\n  _orig_code.clear();\n  _patch_code.clear();\n}\n\nMemoryPatch::MemoryPatch(const char *libraryName, uintptr_t address, \n               const void *patch_code, size_t patch_size, bool useMapCache) {\n  MemoryPatch();\n\n  if (libraryName == NULL || address == 0 || patch_code == NULL || patch_size < 1)\n    return;\n\n  _address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n  if(_address == 0) return;\n  \n  _size    = patch_size;\n\n  _orig_code.resize(patch_size);\n  _patch_code.resize(patch_size);\n\n  // initialize patch & backup current content\n  KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);\n}\n\n\nMemoryPatch::MemoryPatch(uintptr_t absolute_address, \n               const void *patch_code, size_t patch_size) {\n  MemoryPatch();\n\n  if (absolute_address == 0 || patch_code == NULL || patch_size < 1)\n    return;\n\n  _address = absolute_address;  \n  _size    = patch_size;\n\n  _orig_code.resize(patch_size);\n  _patch_code.resize(patch_size);\n\n  // initialize patch & backup current content\n  KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);\n}\n\n   MemoryPatch::~MemoryPatch() {\n     // clean up\n     _orig_code.clear();\n     _patch_code.clear();\n   }\n\n   \n  MemoryPatch MemoryPatch::createWithHex(const char *libraryName, uintptr_t address,\n                std::string hex, bool useMapCache) {\n    MemoryPatch patch;\n\n    if (libraryName == NULL || address == 0 || !KittyUtils::validateHexString(hex))\n      return patch;\n\n    patch._address = KittyMemory::getAbsoluteAddress(libraryName, address, useMapCache);\n    if(patch._address == 0) return patch;\n  \n    patch._size = hex.length() / 2;\n\n    patch._orig_code.resize(patch._size);\n    patch._patch_code.resize(patch._size);\n\n    // initialize patch\n    KittyUtils::fromHex(hex, &patch._patch_code[0]);\n\n    // backup current content\n    KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address), patch._size);\n    return patch;\n  }\n\n  MemoryPatch MemoryPatch::createWithHex(uintptr_t absolute_address, std::string hex) {\n    MemoryPatch patch;\n\n    if (absolute_address == 0 || !KittyUtils::validateHexString(hex))\n      return patch;\n\n    patch._address = absolute_address;\n    patch._size    = hex.length() / 2;\n\n    patch._orig_code.resize(patch._size);\n    patch._patch_code.resize(patch._size);\n\n    // initialize patch\n    KittyUtils::fromHex(hex, &patch._patch_code[0]);\n\n    // backup current content\n    KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address), patch._size);\n    return patch;\n  }\n\n\n  bool MemoryPatch::isValid() const {\n    return (_address != 0 && _size > 0\n            && _orig_code.size() == _size && _patch_code.size() == _size);\n  }\n\n  size_t MemoryPatch::get_PatchSize() const{\n    return _size;\n  }\n\n  uintptr_t MemoryPatch::get_TargetAddress() const{\n    return _address;\n  }\n\n  bool MemoryPatch::Restore() {\n    if (!isValid()) return false;\n    return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) == Memory_Status::SUCCESS;\n  }\n\n  bool MemoryPatch::Modify() {\n    if (!isValid()) return false;\n    return (KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_patch_code[0], _size) == Memory_Status::SUCCESS);\n  }\n\n  std::string MemoryPatch::get_CurrBytes() {\n    if (!isValid()) \n      _hexString = std::string(\"0xInvalid\");\n      else \n      _hexString = KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);\n\n    return _hexString;\n  }\n","size_bytes":3844},"app/src/main/jni/src/Substrate/SubstrateDebug.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#include \"SubstrateHook.h\"\n#include \"SubstrateDebug.hpp\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n_extern bool MSDebug;\nbool MSDebug = false;\n\nstatic char _MSHexChar(uint8_t value) {\n    return value < 0x20 || value >= 0x80 ? '.' : value;\n}\n\n#define HexWidth_ 16\n#define HexDepth_ 4\n\nvoid MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark) {\n    const uint8_t *data((const uint8_t *) vdata);\n\n    size_t i(0), j;\n\n    char d[256];\n    size_t b(0);\n    d[0] = '\\0';\n\n    while (i != size) {\n        if (i % HexWidth_ == 0) {\n            if (mark != NULL)\n                b += sprintf(d + b, \"\\n[%s] \", mark);\n            b += sprintf(d + b, \"0x%.3zx:\", i);\n        }\n\n        b += sprintf(d + b, \" \");\n\n        for (size_t q(0); q != stride; ++q)\n            b += sprintf(d + b, \"%.2x\", data[i + stride - q - 1]);\n\n        i += stride;\n\n        for (size_t q(1); q != stride; ++q)\n            b += sprintf(d + b, \" \");\n\n        if (i % HexDepth_ == 0)\n            b += sprintf(d + b, \" \");\n\n        if (i % HexWidth_ == 0) {\n            b += sprintf(d + b, \" \");\n            for (j = i - HexWidth_; j != i; ++j)\n                b += sprintf(d + b, \"%c\", _MSHexChar(data[j]));\n\n            lprintf(\"%s\", d);\n            b = 0;\n            d[0] = '\\0';\n        }\n    }\n\n    if (i % HexWidth_ != 0) {\n        for (j = i % HexWidth_; j != HexWidth_; ++j)\n            b += sprintf(d + b, \"   \");\n        for (j = 0; j != (HexWidth_ - i % HexWidth_ + HexDepth_ - 1) / HexDepth_; ++j)\n            b += sprintf(d + b, \" \");\n        b += sprintf(d + b, \" \");\n        for (j = i / HexWidth_ * HexWidth_; j != i; ++j)\n            b += sprintf(d + b, \"%c\", _MSHexChar(data[j]));\n\n        lprintf(\"%s\", d);\n        b = 0;\n        d[0] = '\\0';\n    }\n}\n\nvoid MSLogHex(const void *vdata, size_t size, const char *mark) {\n    return MSLogHexEx(vdata, size, 1, mark);\n}\n","size_bytes":2734},"app/src/main/jni/src/Substrate/SubstrateHook.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#define SubstrateInternal\n#include \"CydiaSubstrate.h\"\n\n#include <sys/mman.h>\n\n#define _trace() do { \\\n    MSLog(MSLogLevelNotice, \"_trace(%u)\", __LINE__); \\\n} while (false)\n\n#if defined(__i386__) || defined(__x86_64__)\n#include \"hde64.h\"\n#endif\n\n#include \"SubstrateDebug.hpp\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef __arm__\n/* WebCore (ARM) PC-Relative:\nX    1  ldr r*,[pc,r*] !=\n     2 fldd d*,[pc,#*]\nX    5  str r*,[pc,r*] !=\n     8 flds s*,[pc,#*]\n   400  ldr r*,[pc,r*] ==\n   515  add r*, pc,r*  ==\nX 4790  ldr r*,[pc,#*]    */\n\n// x=0; while IFS= read -r line; do if [[ ${#line} -ne 0 && $line == +([^\\;]): ]]; then x=2; elif [[ $line == ' +'* && $x -ne 0 ]]; then ((--x)); echo \"$x${line}\"; fi; done <WebCore.asm >WebCore.pc\n// grep pc WebCore.pc | cut -c 40- | sed -Ee 's/^ldr *(ip|r[0-9]*),\\[pc,\\#0x[0-9a-f]*\\].*/ ldr r*,[pc,#*]/;s/^add *r[0-9]*,pc,r[0-9]*.*/ add r*, pc,r*/;s/^(st|ld)r *r([0-9]*),\\[pc,r([0-9]*)\\].*/ \\1r r\\2,[pc,r\\3]/;s/^fld(s|d) *(s|d)[0-9]*,\\[pc,#0x[0-9a-f]*].*/fld\\1 \\2*,[pc,#*]/' | sort | uniq -c | sort -n\n\n#include \"SubstrateARM.hpp\"\n\n#define T$Label(l, r) \\\n    (((r) - (l)) * 2 - 4 + ((l) % 2 == 0 ? 0 : 2))\n\n#define T$pop_$r0$ 0xbc01 // pop {r0}\n#define T$b(im) /* b im */ \\\n    (0xde00 | (im & 0xff))\n#define T$blx(rm) /* blx rm */ \\\n    (0x4780 | (rm << 3))\n#define T$bx(rm) /* bx rm */ \\\n    (0x4700 | (rm << 3))\n#define T$nop /* nop */ \\\n    (0x46c0)\n\n#define T$add_rd_rm(rd, rm) /* add rd, rm */ \\\n    (0x4400 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))\n#define T$push_r(r) /* push r... */ \\\n    (0xb400 | (((r) & (1 << A$lr)) >> A$lr << 8) | ((r) & 0xff))\n#define T$pop_r(r) /* pop r... */ \\\n    (0xbc00 | (((r) & (1 << A$pc)) >> A$pc << 8) | ((r) & 0xff))\n#define T$mov_rd_rm(rd, rm) /* mov rd, rm */ \\\n    (0x4600 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))\n#define T$ldr_rd_$rn_im_4$(rd, rn, im) /* ldr rd, [rn, #im * 4] */ \\\n    (0x6800 | (((im) & 0x1f) << 6) | ((rn) << 3) | (rd))\n#define T$ldr_rd_$pc_im_4$(rd, im) /* ldr rd, [PC, #im * 4] */ \\\n    (0x4800 | ((rd) << 8) | ((im) & 0xff))\n#define T$cmp_rn_$im(rn, im) /* cmp rn, #im */ \\\n    (0x2000 | ((rn) << 8) | ((im) & 0xff))\n#define T$it$_cd(cd, ms) /* it<ms>, cd */ \\\n    (0xbf00 | ((cd) << 4) | (ms))\n#define T$cbz$_rn_$im(op,rn,im) /* cb<op>z rn, #im */ \\\n    (0xb100 | ((op) << 11) | (((im) & 0x40) >> 6 << 9) | (((im) & 0x3e) >> 1 << 3) | (rn))\n#define T$b$_$im(cond,im) /* b<cond> #im */ \\\n    (cond == A$al ? 0xe000 | (((im) >> 1) & 0x7ff) : 0xd000 | ((cond) << 8) | (((im) >> 1) & 0xff))\n\n#define T1$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \\\n    (0xf850 | ((im < 0 ? 0 : 1) << 7) | (rn))\n#define T2$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \\\n    (((rt) << 12) | abs((int)(im)))\n\n#define T1$mrs_rd_apsr(rd) /* mrs rd, apsr */ \\\n    (0xf3ef)\n#define T2$mrs_rd_apsr(rd) /* mrs rd, apsr */ \\\n    (0x8000 | ((rd) << 8))\n\n#define T1$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (0xf380 | (rn))\n#define T2$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (0x8c00)\n#define T$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \\\n    (T2$msr_apsr_nzcvqg_rn(rn) << 16 | T1$msr_apsr_nzcvqg_rn(rn))\n\nstatic inline bool A$pcrel$r(uint32_t ic) {\n    return (ic & 0x0c000000) == 0x04000000 && (ic & 0xf0000000) != 0xf0000000 && (ic & 0x000f0000) == 0x000f0000;\n}\n\nstatic inline bool T$32bit$i(uint16_t ic) {\n    return ((ic & 0xe000) == 0xe000 && (ic & 0x1800) != 0x0000);\n}\n\nstatic inline bool T$pcrel$cbz(uint16_t ic) {\n    return (ic & 0xf500) == 0xb100;\n}\n\nstatic inline bool T$pcrel$b(uint16_t ic) {\n    return (ic & 0xf000) == 0xd000 && (ic & 0x0e00) != 0x0e00;\n}\n\nstatic inline bool T2$pcrel$b(uint16_t *ic) {\n    return (ic[0] & 0xf800) == 0xf000 && (((ic[1] & 0xd000) == 0x9000 || (ic[1] & 0xd000) == 0x8000) && (ic[0] & 0x0380) != 0x0380);\n}\n\nstatic inline bool T$pcrel$bl(uint16_t *ic) {\n    return (ic[0] & 0xf800) == 0xf000 && ((ic[1] & 0xd000) == 0xd000 || (ic[1] & 0xd001) == 0xc000);\n}\n\nstatic inline bool T$pcrel$ldr(uint16_t ic) {\n    return (ic & 0xf800) == 0x4800;\n}\n\nstatic inline bool T$pcrel$add(uint16_t ic) {\n    return (ic & 0xff78) == 0x4478;\n}\n\nstatic inline bool T$pcrel$ldrw(uint16_t ic) {\n    return (ic & 0xff7f) == 0xf85f;\n}\n\nstatic size_t MSGetInstructionWidthThumb(void *start) {\n    uint16_t *thumb(reinterpret_cast<uint16_t *>(start));\n    return T$32bit$i(thumb[0]) ? 4 : 2;\n}\n\nstatic size_t MSGetInstructionWidthARM(void *start) {\n    return 4;\n}\n\nextern \"C\" size_t MSGetInstructionWidth(void *start) {\n    if ((reinterpret_cast<uintptr_t>(start) & 0x1) == 0)\n        return MSGetInstructionWidthARM(start);\n    else\n        return MSGetInstructionWidthThumb(reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(start) & ~0x1));\n}\n\nstatic size_t SubstrateHookFunctionThumb(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (symbol == NULL)\n        return 0;\nprintf(\"SubstrateHookFunctionThumb\\n\");\n    uint16_t *area(reinterpret_cast<uint16_t *>(symbol));\n\n    unsigned align((reinterpret_cast<uintptr_t>(area) & 0x2) == 0 ? 0 : 1);\n    uint16_t *thumb(area + align);\n\n    uint32_t *arm(reinterpret_cast<uint32_t *>(thumb + 2));\n    uint16_t *trail(reinterpret_cast<uint16_t *>(arm + 2));\n\n    if (\n        (align == 0 || area[0] == T$nop) &&\n        thumb[0] == T$bx(A$pc) &&\n        thumb[1] == T$nop &&\n        arm[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)\n    ) {\n        if (result != NULL)\n            *result = reinterpret_cast<void *>(arm[1]);\n\n        SubstrateHookMemory code(process, arm + 1, sizeof(uint32_t) * 1);\n\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n\n        return sizeof(arm[0]);\n    }\n\n    size_t required((trail - area) * sizeof(uint16_t));\n\n    size_t used(0);\n    while (used < required)\n        used += MSGetInstructionWidthThumb(reinterpret_cast<uint8_t *>(area) + used);\n    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);\n\n    size_t blank((used - required) / sizeof(uint16_t));\n\n    uint16_t backup[used / sizeof(uint16_t)];\n    memcpy(backup, area, used);\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);\n    }\n\n    if (result != NULL) {\n\n    size_t length(used);\n    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)\n        if (T$pcrel$ldr(backup[offset]))\n            length += 3 * sizeof(uint16_t);\n        else if (T$pcrel$b(backup[offset]))\n            length += 6 * sizeof(uint16_t);\n        else if (T2$pcrel$b(backup + offset)) {\n            length += 5 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$bl(backup + offset)) {\n            length += 5 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$cbz(backup[offset])) {\n            length += 16 * sizeof(uint16_t);\n        } else if (T$pcrel$ldrw(backup[offset])) {\n            length += 4 * sizeof(uint16_t);\n            ++offset;\n        } else if (T$pcrel$add(backup[offset]))\n            length += 6 * sizeof(uint16_t);\n        else if (T$32bit$i(backup[offset]))\n            ++offset;\n\n    unsigned pad((length & 0x2) == 0 ? 0 : 1);\n    length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);\n\n    uint16_t *buffer(reinterpret_cast<uint16_t *>(mmap(\n        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n    )));\n\n    if (buffer == MAP_FAILED) {\n        MSLog(MSLogLevelError, \"MS:Error:mmap() = %d\", errno);\n        *result = NULL;\n        return 0;\n    }\n\n    if (false) fail: {\n        munmap(buffer, length);\n        *result = NULL;\n        return 0;\n    }\n\n    size_t start(pad), end(length / sizeof(uint16_t));\n    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));\n    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {\n        if (T$pcrel$ldr(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 8;\n                    uint16_t rd : 3;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            buffer[start+0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+0, end-2) / 4);\n            buffer[start+1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);\n\n            // XXX: this code \"works\", but is \"wrong\": the mechanism is more complex than this\n            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + bits.immediate * 4;\n\n            start += 2;\n            end -= 2;\n        } else if (T$pcrel$b(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm8 : 8;\n                    uint16_t cond : 4;\n                    uint16_t /*1101*/ : 4;\n                };\n            } bits = {backup[offset+0]};\n\n            intptr_t jump(bits.imm8 << 1);\n            jump |= 1;\n            jump <<= 23;\n            jump >>= 23;\n\n            buffer[start+0] = T$b$_$im(bits.cond, (end-6 - (start+0)) * 2 - 4);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n\n            start += 1;\n            end -= 6;\n        } else if (T2$pcrel$b(backup + offset)) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm6 : 6;\n                    uint16_t cond : 4;\n                    uint16_t s : 1;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t imm11 : 11;\n                    uint16_t j2 : 1;\n                    uint16_t a : 1;\n                    uint16_t j1 : 1;\n                    uint16_t : 2;\n                };\n            } exts = {backup[offset+1]};\n\n            intptr_t jump(1);\n            jump |= exts.imm11 << 1;\n            jump |= bits.imm6 << 12;\n\n            if (exts.a) {\n                jump |= bits.s << 24;\n                jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;\n                jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;\n                jump |= bits.cond << 18;\n                jump <<= 7;\n                jump >>= 7;\n            } else {\n                jump |= bits.s << 20;\n                jump |= exts.j2 << 19;\n                jump |= exts.j1 << 18;\n                jump <<= 11;\n                jump >>= 11;\n            }\n\n            buffer[start+0] = T$b$_$im(exts.a ? A$al : bits.cond, (end-6 - (start+0)) * 2 - 4);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n\n            ++offset;\n            start += 1;\n            end -= 6;\n        } else if (T$pcrel$bl(backup + offset)) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 10;\n                    uint16_t s : 1;\n                    uint16_t : 5;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 11;\n                    uint16_t j2 : 1;\n                    uint16_t x : 1;\n                    uint16_t j1 : 1;\n                    uint16_t : 2;\n                };\n            } exts = {backup[offset+1]};\n\n            int32_t jump(0);\n            jump |= bits.s << 24;\n            jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;\n            jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;\n            jump |= bits.immediate << 12;\n            jump |= exts.immediate << 1;\n            jump |= exts.x;\n            jump <<= 7;\n            jump >>= 7;\n\n            buffer[start+0] = T$push_r(1 << A$r7);\n            buffer[start+1] = T$ldr_rd_$pc_im_4$(A$r7, ((end-2 - (start+1)) * 2 - 4 + 2) / 4);\n            buffer[start+2] = T$mov_rd_rm(A$lr, A$r7);\n            buffer[start+3] = T$pop_r(1 << A$r7);\n            buffer[start+4] = T$blx(A$lr);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n\n            ++offset;\n            start += 5;\n            end -= 2;\n        } else if (T$pcrel$cbz(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t rn : 3;\n                    uint16_t immediate : 5;\n                    uint16_t : 1;\n                    uint16_t i : 1;\n                    uint16_t : 1;\n                    uint16_t op : 1;\n                    uint16_t : 4;\n                };\n            } bits = {backup[offset+0]};\n\n            intptr_t jump(1);\n            jump |= bits.i << 6;\n            jump |= bits.immediate << 1;\n\n            //jump <<= 24;\n            //jump >>= 24;\n\n            unsigned rn(bits.rn);\n            unsigned rt(rn == A$r7 ? A$r6 : A$r7);\n\n            buffer[start+0] = T$push_r(1 << rt);\n            buffer[start+1] = T1$mrs_rd_apsr(rt);\n            buffer[start+2] = T2$mrs_rd_apsr(rt);\n            buffer[start+3] = T$cbz$_rn_$im(bits.op, rn, (end-10 - (start+3)) * 2 - 4);\n            buffer[start+4] = T1$msr_apsr_nzcvqg_rn(rt);\n            buffer[start+5] = T2$msr_apsr_nzcvqg_rn(rt);\n            buffer[start+6] = T$pop_r(1 << rt);\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;\n            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n            *--trailer = T$nop << 16 | T$bx(A$pc);\n            *--trailer = T$nop << 16 | T$pop_r(1 << rt);\n            *--trailer = T$msr_apsr_nzcvqg_rn(rt);\n\n#if 0\n            if ((start & 0x1) == 0)\n                buffer[start++] = T$nop;\n            buffer[start++] = T$bx(A$pc);\n            buffer[start++] = T$nop;\n\n            uint32_t *arm(reinterpret_cast<uint32_t *>(buffer + start));\n            arm[0] = A$add(A$lr, A$pc, 1);\n            arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);\n#endif\n\n            start += 7;\n            end -= 10;\n        } else if (T$pcrel$ldrw(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t : 7;\n                    uint16_t u : 1;\n                    uint16_t : 8;\n                };\n            } bits = {backup[offset+0]};\n\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t immediate : 12;\n                    uint16_t rt : 4;\n                };\n            } exts = {backup[offset+1]};\n\n            buffer[start+0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));\n            buffer[start+1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));\n\n            buffer[start+2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);\n            buffer[start+3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);\n\n            // XXX: this code \"works\", but is \"wrong\": the mechanism is more complex than this\n            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + (bits.u == 0 ? -exts.immediate : exts.immediate);\n\n            ++offset;\n            start += 4;\n            end -= 2;\n        } else if (T$pcrel$add(backup[offset])) {\n            union {\n                uint16_t value;\n\n                struct {\n                    uint16_t rd : 3;\n                    uint16_t rm : 3;\n                    uint16_t h2 : 1;\n                    uint16_t h1 : 1;\n                    uint16_t : 8;\n                };\n            } bits = {backup[offset+0]};\n\n            if (bits.h1) {\n                MSLog(MSLogLevelError, \"MS:Error:pcrel(%u):add (rd > r7)\", offset);\n                goto fail;\n            }\n\n            unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);\n\n            buffer[start+0] = T$push_r(1 << rt);\n            buffer[start+1] = T$mov_rd_rm(rt, (bits.h1 << 3) | bits.rd);\n            buffer[start+2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+2, end-2) / 4);\n            buffer[start+3] = T$add_rd_rm((bits.h1 << 3) | bits.rd, rt);\n            buffer[start+4] = T$pop_r(1 << rt);\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4;\n\n            start += 5;\n            end -= 2;\n        } else if (T$32bit$i(backup[offset])) {\n            buffer[start++] = backup[offset];\n            buffer[start++] = backup[++offset];\n        } else {\n            buffer[start++] = backup[offset];\n        }\n    }\n\n    buffer[start++] = T$bx(A$pc);\n    buffer[start++] = T$nop;\n\n    uint32_t *transfer = reinterpret_cast<uint32_t *>(buffer + start);\n    transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n    transfer[1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint16_t)) + 1;\n\n    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, \"MS:Error:mprotect():%d\", errno);\n        return 0;\n    }\n\n    *result = reinterpret_cast<uint8_t *>(buffer + pad) + 1;\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", *result);\n        MSLogHexEx(buffer, length, 2, name);\n    }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, area, used);\n\n        if (align != 0)\n            area[0] = T$nop;\n\n        thumb[0] = T$bx(A$pc);\n        thumb[1] = T$nop;\n\n        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n\n        for (unsigned offset(0); offset != blank; ++offset)\n            trail[offset] = T$nop;\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);\n    }\n\t\n\treturn used;\n}\n\nstatic size_t SubstrateHookFunctionARM(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (symbol == NULL)\n        return 0;\nprintf(\"SubstrateHookFunctionARM\\n\");\n    uint32_t *area(reinterpret_cast<uint32_t *>(symbol));\n    uint32_t *arm(area);\n\n    const size_t used(8);\n\n    uint32_t backup[used / sizeof(uint32_t)] = {arm[0], arm[1]};\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);\n    }\n\n    if (result != NULL) {\n\n    if (backup[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)) {\n        *result = reinterpret_cast<void *>(backup[1]);\n        \n\t\treturn sizeof(backup[0]);\n    }\n\n    size_t length(used);\n    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)\n        if (A$pcrel$r(backup[offset])) {\n            if ((backup[offset] & 0x02000000) == 0 || (backup[offset] & 0x0000f000 >> 12) != (backup[offset] & 0x0000000f))\n                length += 2 * sizeof(uint32_t);\n            else\n                length += 4 * sizeof(uint32_t);\n        }\n\n    length += 2 * sizeof(uint32_t);\n\n    uint32_t *buffer(reinterpret_cast<uint32_t *>(mmap(\n        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n    )));\n\n    if (buffer == MAP_FAILED) {\n        MSLog(MSLogLevelError, \"MS:Error:mmap() = %d\", errno);\n        *result = NULL;\n        return 0;\n    }\n\n    if (false) fail: {\n        munmap(buffer, length);\n        *result = NULL;\n        return 0;\n    }\n\n    size_t start(0), end(length / sizeof(uint32_t));\n    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));\n    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)\n        if (A$pcrel$r(backup[offset])) {\n            union {\n                uint32_t value;\n\n                struct {\n                    uint32_t rm : 4;\n                    uint32_t : 1;\n                    uint32_t shift : 2;\n                    uint32_t shiftamount : 5;\n                    uint32_t rd : 4;\n                    uint32_t rn : 4;\n                    uint32_t l : 1;\n                    uint32_t w : 1;\n                    uint32_t b : 1;\n                    uint32_t u : 1;\n                    uint32_t p : 1;\n                    uint32_t mode : 1;\n                    uint32_t type : 2;\n                    uint32_t cond : 4;\n                };\n            } bits = {backup[offset+0]}, copy(bits);\n\n            bool guard;\n            if (bits.mode == 0 || bits.rd != bits.rm) {\n                copy.rn = bits.rd;\n                guard = false;\n            } else {\n                copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;\n                guard = true;\n            }\n\n            if (guard)\n                buffer[start++] = A$stmdb_sp$_$rs$((1 << copy.rn));\n\n            buffer[start+0] = A$ldr_rd_$rn_im$(copy.rn, A$pc, (end-1 - (start+0)) * 4 - 8);\n            buffer[start+1] = copy.value;\n\n            start += 2;\n\n            if (guard)\n                buffer[start++] = A$ldmia_sp$_$rs$((1 << copy.rn));\n\n            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 8;\n            end -= 1;\n        } else\n            buffer[start++] = backup[offset];\n\n    buffer[start+0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n    buffer[start+1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint32_t));\n\n    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, \"MS:Error:mprotect():%d\", errno);\n        goto fail;\n    }\n\n    *result = buffer;\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", *result);\n        MSLogHexEx(buffer, length, 4, name);\n    }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, symbol, used);\n\n        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);\n        arm[1] = reinterpret_cast<uint32_t>(replace);\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);\n    }\n\t\n\treturn used;\n}\n\nstatic size_t SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (MSDebug)\n        MSLog(MSLogLevelNotice, \"SubstrateHookFunction(%p, %p, %p, %p)\\n\", process, symbol, replace, result);\n    if ((reinterpret_cast<uintptr_t>(symbol) & 0x1) == 0)\n        return SubstrateHookFunctionARM(process, symbol, replace, result);\n    else\n        return SubstrateHookFunctionThumb(process, reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(symbol) & ~0x1), replace, result);\n}\n#endif\n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include \"SubstrateX86.hpp\"\n\nstatic size_t MSGetInstructionWidthIntel(void *start) {\n    hde64s decode;\n    return hde64_disasm(start, &decode);\n}\n\nstatic void SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {\n    if (MSDebug)\n        MSLog(MSLogLevelNotice, \"MSHookFunction(%p, %p, %p)\\n\", symbol, replace, result);\n    if (symbol == NULL)\n        return;\n\n    uintptr_t source(reinterpret_cast<uintptr_t>(symbol));\n    uintptr_t target(reinterpret_cast<uintptr_t>(replace));\n\n    uint8_t *area(reinterpret_cast<uint8_t *>(symbol));\n\n    size_t required(MSSizeOfJump(target, source));\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHex(area, 32, name);\n    }\n\n    size_t used(0);\n    while (used < required) {\n        size_t width(MSGetInstructionWidthIntel(area + used));\n        if (width == 0) {\n            MSLog(MSLogLevelError, \"MS:Error:MSGetInstructionWidthIntel(%p) == 0\", area + used);\n            return;\n        }\n\n        used += width;\n    }\n\n    size_t blank(used - required);\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHex(area, used + sizeof(uint16_t), name);\n    }\n\n    uint8_t backup[used];\n    memcpy(backup, area, used);\n\n    if (result != NULL) {\n\n    if (backup[0] == 0xe9) {\n        *result = reinterpret_cast<void *>(source + 5 + *reinterpret_cast<uint32_t *>(backup + 1));\n        return;\n    }\n\n    if (!ia32 && backup[0] == 0xff && backup[1] == 0x25) {\n        *result = *reinterpret_cast<void **>(source + 6 + *reinterpret_cast<uint32_t *>(backup + 2));\n        return;\n    }\n\n    size_t length(used + MSSizeOfJump(source + used));\n\n    for (size_t offset(0), width; offset != used; offset += width) {\n        hde64s decode;\n        hde64_disasm(backup + offset, &decode);\n        width = decode.len;\n        //_assert(width != 0 && offset + width <= used);\n\n#ifdef __LP64__\n        if ((decode.modrm & 0xc7) == 0x05) {\n            if (decode.opcode == 0x8b) {\n                void *destiny(area + offset + width + int32_t(decode.disp.disp32));\n                uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);\n                length -= decode.len;\n                length += MSSizeOfPushPointer(destiny);\n                length += MSSizeOfPop(reg);\n                length += MSSizeOfMove64();\n            } else {\n                MSLog(MSLogLevelError, \"MS:Error: Unknown RIP-Relative (%.2x %.2x)\", decode.opcode, decode.opcode2);\n                continue;\n            }\n        } else\n#endif\n\n        if (backup[offset] == 0xe8) {\n            int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));\n            void *destiny(area + offset + decode.len + relative);\n\n            if (relative == 0) {\n                length -= decode.len;\n                length += MSSizeOfPushPointer(destiny);\n            } else {\n                length += MSSizeOfSkip();\n                length += MSSizeOfJump(destiny);\n            }\n        } else if (backup[offset] == 0xeb) {\n            length -= decode.len;\n            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));\n        } else if (backup[offset] == 0xe9) {\n            length -= decode.len;\n            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int32_t *>(backup + offset + 1));\n        } else if (\n            backup[offset] == 0xe3 ||\n            (backup[offset] & 0xf0) == 0x70\n            // XXX: opcode2 & 0xf0 is 0x80?\n        ) {\n            length += decode.len;\n            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));\n        }\n    }\n\n    uint8_t *buffer(reinterpret_cast<uint8_t *>(mmap(\n        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0\n    )));\n\n    if (buffer == MAP_FAILED) {\n        MSLog(MSLogLevelError, \"MS:Error:mmap() = %d\", errno);\n        *result = NULL;\n        return;\n    }\n\n    if (false) fail: {\n        munmap(buffer, length);\n        *result = NULL;\n        return;\n    }\n\n    {\n        uint8_t *current(buffer);\n\n        for (size_t offset(0), width; offset != used; offset += width) {\n            hde64s decode;\n            hde64_disasm(backup + offset, &decode);\n            width = decode.len;\n            //_assert(width != 0 && offset + width <= used);\n\n#ifdef __LP64__\n            if ((decode.modrm & 0xc7) == 0x05) {\n                if (decode.opcode == 0x8b) {\n                    void *destiny(area + offset + width + int32_t(decode.disp.disp32));\n                    uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);\n                    MSPushPointer(current, destiny);\n                    MSWritePop(current, reg);\n                    MSWriteMove64(current, reg, reg);\n                } else {\n                    MSLog(MSLogLevelError, \"MS:Error: Unknown RIP-Relative (%.2x %.2x)\", decode.opcode, decode.opcode2);\n                    goto copy;\n                }\n            } else\n#endif\n\n            if (backup[offset] == 0xe8) {\n                int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));\n                if (relative == 0)\n                    MSPushPointer(current, area + offset + decode.len);\n                else {\n                    MSWrite<uint8_t>(current, 0xe8);\n                    MSWrite<int32_t>(current, MSSizeOfSkip());\n                    void *destiny(area + offset + decode.len + relative);\n                    MSWriteSkip(current, MSSizeOfJump(destiny, current + MSSizeOfSkip()));\n                    MSWriteJump(current, destiny);\n                }\n            } else if (backup[offset] == 0xeb)\n                MSWriteJump(current, area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));\n            else if (backup[offset] == 0xe9)\n                MSWriteJump(current, area + offset + decode.len + *reinterpret_cast<int32_t *>(backup + offset + 1));\n            else if (\n                backup[offset] == 0xe3 ||\n                (backup[offset] & 0xf0) == 0x70\n            ) {\n                MSWrite<uint8_t>(current, backup[offset]);\n                MSWrite<uint8_t>(current, 2);\n                MSWrite<uint8_t>(current, 0xeb);\n                void *destiny(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));\n                MSWrite<uint8_t>(current, MSSizeOfJump(destiny, current + 1));\n                MSWriteJump(current, destiny);\n            } else\n#ifdef __LP64__\n                copy:\n#endif\n            {\n                MSWrite(current, backup + offset, width);\n            }\n        }\n\n        MSWriteJump(current, area + used);\n    }\n\n    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, \"MS:Error:mprotect():%d\", errno);\n        goto fail;\n    }\n\n    *result = buffer;\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", *result);\n        MSLogHex(buffer, length, name);\n    }\n\n    }\n\n    {\n        SubstrateHookMemory code(process, area, used);\n\n        uint8_t *current(area);\n        MSWriteJump(current, target);\n        for (unsigned offset(0); offset != blank; ++offset)\n            MSWrite<uint8_t>(current, 0x90);\n    }\n\n    if (MSDebug) {\n        char name[16];\n        sprintf(name, \"%p\", area);\n        MSLogHex(area, used + sizeof(uint16_t), name);\n    }\n}\n#endif\n\n_extern void MSHookFunction(void *symbol, void *replace, void **result) {\n#if defined(__i386__) || defined(__x86_64__) || defined(__arm__)\n     SubstrateHookFunction(NULL, symbol, replace, result);\n#endif\n}\n\n\n#if defined(__APPLE__) && defined(__arm__)\n_extern void _Z14MSHookFunctionPvS_PS_(void *symbol, void *replace, void **result) {\n    return MSHookFunction(symbol, replace, result);\n}\n#endif\n","size_bytes":30937},"app/src/main/jni/src/Substrate/SubstratePosixMemory.cpp":{"content":"/* Cydia Substrate - Powerful Code Insertion Platform\n * Copyright (C) 2008-2011  Jay Freeman (saurik)\n*/\n\n/* GNU Lesser General Public License, Version 3 {{{ */\n/*\n * Substrate is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the\n * Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n *\n * Substrate is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.\n**/\n/* }}} */\n\n#define SubstrateInternal\n#include \"CydiaSubstrate.h\"\n#include \"SubstrateLog.hpp\"\n\n#include <sys/mman.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n\nextern \"C\" void __clear_cache (void *beg, void *end);\n\nstruct __SubstrateMemory {\n    void *address_;\n    size_t width_;\n\n    __SubstrateMemory(void *address, size_t width) :\n        address_(address),\n        width_(width)\n    {\n    }\n};\n\nextern \"C\" SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size) {\n    if (allocator != NULL) {\n        MSLog(MSLogLevelError, \"MS:Error:allocator != %d\", 0);\n        return NULL;\n    }\n\n    if (size == 0)\n        return NULL;\n\n    int page(getpagesize());\n\n    uintptr_t base(reinterpret_cast<uintptr_t>(data) / page * page);\n    size_t width(((reinterpret_cast<uintptr_t>(data) + size - 1) / page + 1) * page - base);\n    void *address(reinterpret_cast<void *>(base));\n\n    if (mprotect(address, width, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {\n        MSLog(MSLogLevelError, \"MS:Error:mprotect() = %d\", errno);\n        return NULL;\n    }\n\n    return new __SubstrateMemory(address, width);\n}\n\nextern \"C\" void SubstrateMemoryRelease(SubstrateMemoryRef memory) {\n    if (mprotect(memory->address_, memory->width_, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)\n        MSLog(MSLogLevelError, \"MS:Error:mprotect() = %d\", errno);\n\n    __clear_cache(reinterpret_cast<char *>(memory->address_), reinterpret_cast<char *>(memory->address_) + memory->width_);\n\n    delete memory;\n}\n","size_bytes":2391},"app/src/main/jni/src/Substrate/SymbolFinder.cpp":{"content":"#include <stdio.h>\n#include <elf.h>\n#include <android/log.h>\n#include <malloc.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <cstring>\n#include \"SymbolFinder.h\"\n\n#define TAG \"MSHook\"\n#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,  TAG, __VA_ARGS__)\n#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)\n/* memory map for libraries */\n#define MAX_NAME_LEN 256\n#define MEMORY_ONLY  \"[memory]\"\nstruct mm {\n    char name[MAX_NAME_LEN];\n    unsigned long start, end;\n};\n\ntypedef struct symtab *symtab_t;\nstruct symlist {\n    Elf32_Sym *sym; /* symbols */\n    char *str; /* symbol strings */\n    unsigned num; /* number of symbols */\n};\nstruct symtab {\n    struct symlist *st; /* \"static\" symbols */\n    struct symlist *dyn; /* dynamic symbols */\n};\n\nstatic void* xmalloc(size_t size) {\n    void *p;\n    p = malloc(size);\n    if (!p) {\n        printf(\"Out of memory\\n\");\n        exit(1);\n    }\n    return p;\n}\n\nstatic int my_pread(int fd, void *buf, size_t count, off_t offset) {\n    lseek(fd, offset, SEEK_SET);\n    return read(fd, buf, count);\n}\n\nstatic struct symlist* get_syms(int fd, Elf32_Shdr *symh, Elf32_Shdr *strh) {\n    struct symlist *sl, *ret;\n    int rv;\n\n    ret = NULL;\n    sl = (struct symlist *) xmalloc(sizeof(struct symlist));\n    sl->str = NULL;\n    sl->sym = NULL;\n\n    /* sanity */\n    if (symh->sh_size % sizeof(Elf32_Sym)) {\n        //printf(\"elf_error\\n\");\n        goto out;\n    }\n\n    /* symbol table */\n    sl->num = symh->sh_size / sizeof(Elf32_Sym);\n    sl->sym = (Elf32_Sym *) xmalloc(symh->sh_size);\n    rv = my_pread(fd, sl->sym, symh->sh_size, symh->sh_offset);\n    if (0 > rv) {\n        //perror(\"read\");\n        goto out;\n    }\n    if (rv != symh->sh_size) {\n        //printf(\"elf error\\n\");\n        goto out;\n    }\n\n    /* string table */\n    sl->str = (char *) xmalloc(strh->sh_size);\n    rv = my_pread(fd, sl->str, strh->sh_size, strh->sh_offset);\n    if (0 > rv) {\n        //perror(\"read\");\n        goto out;\n    }\n    if (rv != strh->sh_size) {\n        //printf(\"elf error\");\n        goto out;\n    }\n\n    ret = sl;\n    out: return ret;\n}\n\nstatic int do_load(int fd, symtab_t symtab) {\n    int rv;\n    size_t size;\n    Elf32_Ehdr ehdr;\n    Elf32_Shdr *shdr = NULL, *p;\n    Elf32_Shdr *dynsymh, *dynstrh;\n    Elf32_Shdr *symh, *strh;\n    char *shstrtab = NULL;\n    int i;\n    int ret = -1;\n\n    /* elf header */\n    rv = read(fd, &ehdr, sizeof(ehdr));\n    if (0 > rv) {\n        LOGD(\"read\\n\");\n        goto out;\n    }\n    if (rv != sizeof(ehdr)) {\n        LOGD(\"elf error 1\\n\");\n        goto out;\n    }\n    if (strncmp((const char *) ELFMAG, (const char *) ehdr.e_ident, SELFMAG)) { /* sanity */\n        LOGD(\"not an elf\\n\");\n        goto out;\n    }\n    if (sizeof(Elf32_Shdr) != ehdr.e_shentsize) { /* sanity */\n        LOGD(\"elf error 2\\n\");\n        goto out;\n    }\n\n    /* section header table */\n    size = ehdr.e_shentsize * ehdr.e_shnum;\n    shdr = (Elf32_Shdr *) xmalloc(size);\n    rv = my_pread(fd, shdr, size, ehdr.e_shoff);\n    if (0 > rv) {\n        LOGD(\"read\\n\");\n        goto out;\n    }\n    if (rv != size) {\n        LOGD(\"elf error 3 %d %d\\n\", rv, size);\n        goto out;\n    }\n\n    /* section header string table */\n    size = shdr[ehdr.e_shstrndx].sh_size;\n    shstrtab = (char *) xmalloc(size);\n    rv = my_pread(fd, shstrtab, size, shdr[ehdr.e_shstrndx].sh_offset);\n    if (0 > rv) {\n        LOGD(\"read\\n\");\n        goto out;\n    }\n    if (rv != size) {\n        LOGD(\"elf error 4 %d %d\\n\", rv, size);\n        goto out;\n    }\n\n    /* symbol table headers */\n    symh = dynsymh = NULL;\n    strh = dynstrh = NULL;\n    for (i = 0, p = shdr; i < ehdr.e_shnum; i++, p++)\n        if (SHT_SYMTAB == p->sh_type) {\n            if (symh) {\n                LOGD(\"too many symbol tables\\n\");\n                goto out;\n            }\n            symh = p;\n        } else if (SHT_DYNSYM == p->sh_type) {\n            if (dynsymh) {\n                LOGD(\"too many symbol tables\\n\");\n                goto out;\n            }\n            dynsymh = p;\n        } else if (SHT_STRTAB == p->sh_type\n                   && !strncmp(shstrtab + p->sh_name, \".strtab\", 7)) {\n            if (strh) {\n                LOGD(\"too many string tables\\n\");\n                goto out;\n            }\n            strh = p;\n        } else if (SHT_STRTAB == p->sh_type\n                   && !strncmp(shstrtab + p->sh_name, \".dynstr\", 7)) {\n            if (dynstrh) {\n                LOGD(\"too many string tables\\n\");\n                goto out;\n            }\n            dynstrh = p;\n        }\n    /* sanity checks */\n    if ((!dynsymh && dynstrh) || (dynsymh && !dynstrh)) {\n        LOGD(\"bad dynamic symbol table\\n\");\n        goto out;\n    }\n    if ((!symh && strh) || (symh && !strh)) {\n        LOGD(\"bad symbol table\\n\");\n        goto out;\n    }\n    if (!dynsymh && !symh) {\n        LOGD(\"no symbol table\\n\");\n        goto out;\n    }\n\n    /* symbol tables */\n    if (dynsymh)\n        symtab->dyn = get_syms(fd, dynsymh, dynstrh);\n    if (symh)\n        symtab->st = get_syms(fd, symh, strh);\n    ret = 0;\n    out: free(shstrtab);\n    free(shdr);\n    return ret;\n}\n\nstatic symtab_t load_symtab(char *filename) {\n    int fd;\n    symtab_t symtab;\n\n    symtab = (symtab_t) xmalloc(sizeof(*symtab));\n    memset(symtab, 0, sizeof(*symtab));\n\n    fd = open(filename, O_RDONLY);\n    if (0 > fd) {\n        LOGE(\"%s open\\n\", __func__);\n        return NULL;\n    }\n    if (0 > do_load(fd, symtab)) {\n        LOGE(\"Error ELF parsing %s\\n\", filename);\n        free(symtab);\n        symtab = NULL;\n    }\n    close(fd);\n    return symtab;\n}\n\nstatic int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {\n    size_t buf_size = 0x40000;\n    char *p_buf = (char *) malloc(buf_size); // increase this if needed for larger \"maps\"\n    char name[MAX_NAME_LEN] = { 0 };\n    char *p;\n    unsigned long start, end;\n    struct mm *m;\n    int nmm = 0;\n    int fd, rv;\n    int i;\n\n    sprintf(p_buf, \"/proc/%d/maps\", pid);\n    fd = open(p_buf, O_RDONLY);\n    if (0 > fd) {\n        LOGE(\"Can't open %s for reading\\n\", p_buf);\n        free(p_buf);\n        return -1;\n    }\n\n    /* Zero to ensure data is null terminated */\n    memset(p_buf, 0, buf_size);\n\n    p = p_buf;\n    while (1) {\n        rv = read(fd, p, buf_size - (p - p_buf));\n        if (0 > rv) {\n            LOGE(\"%s read\", __FUNCTION__);\n            free(p_buf);\n            return -1;\n        }\n        if (0 == rv)\n            break;\n        p += rv;\n        if (p - p_buf >= buf_size) {\n            LOGE(\"Too many memory mapping\\n\");\n            free(p_buf);\n            return -1;\n        }\n    }\n    close(fd);\n\n    p = strtok(p_buf, \"\\n\");\n    m = mm;\n    while (p) {\n        /* parse current map line */\n        rv = sscanf(p, \"%08lx-%08lx %*s %*s %*s %*s %s\\n\", &start, &end, name);\n\n        p = strtok(NULL, \"\\n\");\n\n        if (rv == 2) {\n            m = &mm[nmm++];\n            m->start = start;\n            m->end = end;\n            memcpy(m->name, MEMORY_ONLY, sizeof(MEMORY_ONLY));\n            continue;\n        }\n\n        /* search backward for other mapping with same name */\n        for (i = nmm - 1; i >= 0; i--) {\n            m = &mm[i];\n            if (!strcmp(m->name, name))\n                break;\n        }\n\n        if (i >= 0) {\n            if (start < m->start)\n                m->start = start;\n            if (end > m->end)\n                m->end = end;\n        } else {\n            /* new entry */\n            m = &mm[nmm++];\n            m->start = start;\n            m->end = end;\n            memcpy(m->name, name, strlen(name));\n        }\n    }\n\n    *nmmp = nmm;\n    free(p_buf);\n    return 0;\n}\n\n/* Find libc in MM, storing no more than LEN-1 chars of\n its name in NAME and set START to its starting\n address.  If libc cannot be found return -1 and\n leave NAME and START untouched.  Otherwise return 0\n and null-terminated NAME. */\nstatic int find_libname(const char *libn, char *name, int len, unsigned long *start,\n                        struct mm *mm, int nmm) {\n    int i;\n    struct mm *m;\n    char *p;\n    for (i = 0, m = mm; i < nmm; i++, m++) {\n        if (!strcmp(m->name, MEMORY_ONLY))\n            continue;\n        p = strrchr(m->name, '/');\n        if (!p)\n            continue;\n        p++;\n        if (strncmp(libn, p, strlen(libn)))\n            continue;\n        p += strlen(libn);\n\n        /* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */\n        if (!strncmp(\"so\", p, 2) || 1) // || (p[0] == '-' && isdigit(p[1])))\n            break;\n    }\n    if (i >= nmm)\n        /* not found */\n        return -1;\n\n    *start = m->start;\n    strncpy(name, m->name, len);\n    if (strlen(m->name) >= len)\n        name[len - 1] = '\\0';\n\n    mprotect((void*) m->start, m->end - m->start,\n             PROT_READ | PROT_WRITE | PROT_EXEC);\n    return 0;\n}\n\nstatic int lookup2(struct symlist *sl, unsigned char type, char *name,\n                   unsigned long *val) {\n    Elf32_Sym *p;\n    int len;\n    int i;\n\n    len = strlen(name);\n    for (i = 0, p = sl->sym; i < sl->num; i++, p++) {\n        //LOGD(\"name: %s %x\\n\", sl->str+p->st_name, p->st_value)\n        if (!strncmp(sl->str + p->st_name, name, len)\n            && *(sl->str + p->st_name + len) == 0\n            && ELF32_ST_TYPE(p->st_info) == type) {\n            //if (p->st_value != 0) {\n            *val = p->st_value;\n            return 0;\n            //}\n        }\n    }\n    return -1;\n}\n\nstatic int lookup_sym(symtab_t s, unsigned char type, char *name,\n                      unsigned long *val) {\n    if (s->dyn && !lookup2(s->dyn, type, name, val))\n        return 0;\n    if (s->st && !lookup2(s->st, type, name, val))\n        return 0;\n    return -1;\n}\n\nstatic int lookup_func_sym(symtab_t s, char *name, unsigned long *val) {\n    return lookup_sym(s, STT_FUNC, name, val);\n}\n\nint find_name(pid_t pid, const char *name, const char *libn,\n              unsigned long *addr) {\n    struct mm mm[1000] = { 0 };\n    unsigned long libcaddr;\n    int nmm;\n    char libc[1024] = { 0 };\n    symtab_t s;\n\n    if (0 > load_memmap(pid, mm, &nmm)) {\n        LOGD(\"cannot read memory map\\n\");\n        return -1;\n    }\n    if (0\n        > find_libname((char *) libn, (char *) libc, sizeof(libc),\n                       &libcaddr, mm, nmm)) {\n        LOGD(\"cannot find lib: %s\\n\", libn);\n        return -1;\n    }\n    //LOGD(\"lib: >%s<\\n\", libc)\n    s = load_symtab(libc);\n    if (!s) {\n        LOGD(\"cannot read symbol table\\n\");\n        return -1;\n    }\n    if (0 > lookup_func_sym(s, (char *) name, addr)) {\n        LOGD(\"cannot find function: %s\\n\", name);\n        return -1;\n    }\n    *addr += libcaddr;\n    return 0;\n}\n\nint find_libbase(pid_t pid, const char *libn, unsigned long *addr) {\n    struct mm mm[1000] = { 0 };\n    unsigned long libcaddr;\n    int nmm;\n    char libc[1024] = { 0 };\n    symtab_t s;\n\n    if (0 > load_memmap(pid, mm, &nmm)) {\n        LOGD(\"cannot read memory map\\n\");\n        return -1;\n    }\n    if (0 > find_libname(libn, libc, sizeof(libc), &libcaddr, mm, nmm)) {\n        LOGD(\"cannot find lib\\n\");\n        return -1;\n    }\n    *addr = libcaddr;\n    return 0;\n}\n","size_bytes":11084},"app/src/main/jni/src/Substrate/hde64.c":{"content":"/*\n * Hacker Disassembler Engine 64 C\n * Copyright (c) 2008-2009, Vyacheslav Patkov.\n * All rights reserved.\n *\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"hde64.h\"\n#include \"table64.h\"\n\nunsigned int hde64_disasm(const void *code, hde64s *hs)\n{\n    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;\n    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;\n    uint8_t op64 = 0;\n\n    memset(hs,0,sizeof(hde64s));\n    char *tmp=(char*)hs;\n\n    for (x = 16; x; x--)\n        switch (c = *p++) {\n            case 0xf3:\n                hs->p_rep = c;\n                pref |= PRE_F3;\n                break;\n            case 0xf2:\n                hs->p_rep = c;\n                pref |= PRE_F2;\n                break;\n            case 0xf0:\n                hs->p_lock = c;\n                pref |= PRE_LOCK;\n                break;\n            case 0x26: case 0x2e: case 0x36:\n            case 0x3e: case 0x64: case 0x65:\n                hs->p_seg = c;\n                pref |= PRE_SEG;\n                break;\n            case 0x66:\n                hs->p_66 = c;\n                pref |= PRE_66;\n                break;\n            case 0x67:\n                hs->p_67 = c;\n                pref |= PRE_67;\n                break;\n            default:\n                goto pref_done;\n        }\n  pref_done:\n\n    hs->flags = (uint32_t)pref << 23;\n\n    if (!pref)\n        pref |= PRE_NONE;\n\n    if ((c & 0xf0) == 0x40) {\n        hs->flags |= F_PREFIX_REX;\n        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)\n            op64++;\n        hs->rex_r = (c & 7) >> 2;\n        hs->rex_x = (c & 3) >> 1;\n        hs->rex_b = c & 1;\n        if (((c = *p++) & 0xf0) == 0x40) {\n            opcode = c;\n            goto error_opcode;\n        }\n    }\n\n    if ((hs->opcode = c) == 0x0f) {\n        hs->opcode2 = c = *p++;\n        ht += DELTA_OPCODES;\n    } else if (c >= 0xa0 && c <= 0xa3) {\n        op64++;\n        if (pref & PRE_67)\n            pref |= PRE_66;\n        else\n            pref &= ~PRE_66;\n    }\n\n    opcode = c;\n    cflags = ht[ht[opcode / 4] + (opcode % 4)];\n\n    if (cflags == C_ERROR) {\n      error_opcode:\n        hs->flags |= F_ERROR | F_ERROR_OPCODE;\n        cflags = 0;\n        if ((opcode & -3) == 0x24)\n            cflags++;\n    }\n\n    x = 0;\n    if (cflags & C_GROUP) {\n        uint16_t t;\n        t = *(uint16_t *)(ht + (cflags & 0x7f));\n        cflags = (uint8_t)t;\n        x = (uint8_t)(t >> 8);\n    }\n\n    if (hs->opcode2) {\n        ht = hde64_table + DELTA_PREFIXES;\n        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)\n            hs->flags |= F_ERROR | F_ERROR_OPCODE;\n    }\n\n    if (cflags & C_MODRM) {\n        hs->flags |= F_MODRM;\n        hs->modrm = c = *p++;\n        hs->modrm_mod = m_mod = c >> 6;\n        hs->modrm_rm = m_rm = c & 7;\n        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;\n\n        if (x && ((x << m_reg) & 0x80))\n            hs->flags |= F_ERROR | F_ERROR_OPCODE;\n\n        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {\n            uint8_t t = opcode - 0xd9;\n            if (m_mod == 3) {\n                ht = hde64_table + DELTA_FPU_MODRM + t*8;\n                t = ht[m_reg] << m_rm;\n            } else {\n                ht = hde64_table + DELTA_FPU_REG;\n                t = ht[t] << m_reg;\n            }\n            if (t & 0x80)\n                hs->flags |= F_ERROR | F_ERROR_OPCODE;\n        }\n\n        if (pref & PRE_LOCK) {\n            if (m_mod == 3) {\n                hs->flags |= F_ERROR | F_ERROR_LOCK;\n            } else {\n                uint8_t *table_end, op = opcode;\n                if (hs->opcode2) {\n                    ht = hde64_table + DELTA_OP2_LOCK_OK;\n                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;\n                } else {\n                    ht = hde64_table + DELTA_OP_LOCK_OK;\n                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;\n                    op &= -2;\n                }\n                for (; ht != table_end; ht++)\n                    if (*ht++ == op) {\n                        if (!((*ht << m_reg) & 0x80))\n                            goto no_lock_error;\n                        else\n                            break;\n                    }\n                hs->flags |= F_ERROR | F_ERROR_LOCK;\n              no_lock_error:\n                ;\n            }\n        }\n\n        if (hs->opcode2) {\n            switch (opcode) {\n                case 0x20: case 0x22:\n                    m_mod = 3;\n                    if (m_reg > 4 || m_reg == 1)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n                case 0x21: case 0x23:\n                    m_mod = 3;\n                    if (m_reg == 4 || m_reg == 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n            }\n        } else {\n            switch (opcode) {\n                case 0x8c:\n                    if (m_reg > 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n                case 0x8e:\n                    if (m_reg == 1 || m_reg > 5)\n                        goto error_operand;\n                    else\n                        goto no_error_operand;\n            }\n        }\n\n        if (m_mod == 3) {\n            uint8_t *table_end;\n            if (hs->opcode2) {\n                ht = hde64_table + DELTA_OP2_ONLY_MEM;\n                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;\n            } else {\n                ht = hde64_table + DELTA_OP_ONLY_MEM;\n                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;\n            }\n            for (; ht != table_end; ht += 2)\n                if (*ht++ == opcode) {\n                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))\n                        goto error_operand;\n                    else\n                        break;\n                }\n            goto no_error_operand;\n        } else if (hs->opcode2) {\n            switch (opcode) {\n                case 0x50: case 0xd7: case 0xf7:\n                    if (pref & (PRE_NONE | PRE_66))\n                        goto error_operand;\n                    break;\n                case 0xd6:\n                    if (pref & (PRE_F2 | PRE_F3))\n                        goto error_operand;\n                    break;\n                case 0xc5:\n                    goto error_operand;\n            }\n            goto no_error_operand;\n        } else\n            goto no_error_operand;\n\n      error_operand:\n        hs->flags |= F_ERROR | F_ERROR_OPERAND;\n      no_error_operand:\n\n        c = *p++;\n        if (m_reg <= 1) {\n            if (opcode == 0xf6)\n                cflags |= C_IMM8;\n            else if (opcode == 0xf7)\n                cflags |= C_IMM_P66;\n        }\n\n        switch (m_mod) {\n            case 0:\n                if (pref & PRE_67) {\n                    if (m_rm == 6)\n                        disp_size = 2;\n                } else\n                    if (m_rm == 5)\n                        disp_size = 4;\n                break;\n            case 1:\n                disp_size = 1;\n                break;\n            case 2:\n                disp_size = 2;\n                if (!(pref & PRE_67))\n                    disp_size <<= 1;\n        }\n\n        if (m_mod != 3 && m_rm == 4) {\n            hs->flags |= F_SIB;\n            p++;\n            hs->sib = c;\n            hs->sib_scale = c >> 6;\n            hs->sib_index = (c & 0x3f) >> 3;\n            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))\n                disp_size = 4;\n        }\n\n        p--;\n        switch (disp_size) {\n            case 1:\n                hs->flags |= F_DISP8;\n                hs->disp.disp8 = *p;\n                break;\n            case 2:\n                hs->flags |= F_DISP16;\n                hs->disp.disp16 = *(uint16_t *)p;\n                break;\n            case 4:\n                hs->flags |= F_DISP32;\n                hs->disp.disp32 = *(uint32_t *)p;\n        }\n        p += disp_size;\n    } else if (pref & PRE_LOCK)\n        hs->flags |= F_ERROR | F_ERROR_LOCK;\n\n    if (cflags & C_IMM_P66) {\n        if (cflags & C_REL32) {\n            if (pref & PRE_66) {\n                hs->flags |= F_IMM16 | F_RELATIVE;\n                hs->imm.imm16 = *(uint16_t *)p;\n                p += 2;\n                goto disasm_done;\n            }\n            goto rel32_ok;\n        }\n        if (op64) {\n            hs->flags |= F_IMM64;\n            hs->imm.imm64 = *(uint64_t *)p;\n            p += 8;\n        } else if (!(pref & PRE_66)) {\n            hs->flags |= F_IMM32;\n            hs->imm.imm32 = *(uint32_t *)p;\n            p += 4;\n        } else\n            goto imm16_ok;\n    }\n\n\n    if (cflags & C_IMM16) {\n      imm16_ok:\n        hs->flags |= F_IMM16;\n        hs->imm.imm16 = *(uint16_t *)p;\n        p += 2;\n    }\n    if (cflags & C_IMM8) {\n        hs->flags |= F_IMM8;\n        hs->imm.imm8 = *p++;\n    }\n\n    if (cflags & C_REL32) {\n      rel32_ok:\n        hs->flags |= F_IMM32 | F_RELATIVE;\n        hs->imm.imm32 = *(uint32_t *)p;\n        p += 4;\n    } else if (cflags & C_REL8) {\n        hs->flags |= F_IMM8 | F_RELATIVE;\n        hs->imm.imm8 = *p++;\n    }\n\n  disasm_done:\n\n    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {\n        hs->flags |= F_ERROR | F_ERROR_LENGTH;\n        hs->len = 15;\n    }\n\n    return (unsigned int)hs->len;\n}\n","size_bytes":9406},"app/src/main/java/uk/lgl/modmenu/CrashHandler.java":{"content":"package uk.lgl.modmenu;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Application;\nimport android.content.ActivityNotFoundException;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.text.Html;\nimport android.text.InputFilter;\nimport android.text.InputType;\nimport android.text.TextUtils;\nimport android.text.method.DigitsKeyListener;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.LinearLayout;\nimport android.widget.ScrollView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.Thread.UncaughtExceptionHandler;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic final class CrashHandler {\n\n    public static final UncaughtExceptionHandler DEFAULT_UNCAUGHT_EXCEPTION_HANDLER = Thread.getDefaultUncaughtExceptionHandler();\n\n    public static void init(final Context app, final boolean overlayRequired) {\n        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n\n                @Override\n                public void uncaughtException(Thread thread, Throwable throwable) {\n                    Log.e(\"AppCrash\", \"Error just lunched \");\n                    try {\n                        tryUncaughtException(thread, throwable);\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                        if (DEFAULT_UNCAUGHT_EXCEPTION_HANDLER != null)\n                            DEFAULT_UNCAUGHT_EXCEPTION_HANDLER.uncaughtException(thread, throwable);\n                        else\n                            System.exit(2);\n                    }\n                }\n\n                private void tryUncaughtException(Thread thread, Throwable throwable) {\n                    Log.e(\"AppCrash\", \"Try saving log\");\n\n                    final String time = new SimpleDateFormat(\"yyyy_MM_dd-HH_mm_ss\").format(new Date());\n                    String fileName = \"mod_menu_crash_\" + time + \".txt\";\n                    String dirName;\n\n                    if (Build.VERSION.SDK_INT >= 30) { //Android R. AIDE didn't support Build.VERSION_CODES.R\n                        dirName = \"/storage/emulated/0/Documents/\";\n                    } else {\n                        dirName = String.valueOf(app.getExternalFilesDir(null));\n                    }\n\n                    File crashFile = new File(dirName, fileName);\n\n                    String versionName = \"unknown\";\n                    long versionCode = 0;\n                    try {\n                        PackageInfo packageInfo = app.getPackageManager().getPackageInfo(app.getPackageName(), 0);\n                        versionName = packageInfo.versionName;\n                        versionCode = Build.VERSION.SDK_INT >= 28 ? packageInfo.getLongVersionCode()\n                            : packageInfo.versionCode;\n                    } catch (PackageManager.NameNotFoundException ignored) {\n                    }\n\n                    String fullStackTrace;\n                    {\n                        StringWriter sw = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        throwable.printStackTrace(pw);\n                        fullStackTrace = sw.toString();\n                        pw.close();\n                    }\n\n                    StringBuilder devInfo = new StringBuilder();\n                    devInfo.append(\"************* Crash Head ****************\\n\");\n                    devInfo.append(\"Time Of Crash      : \").append(time).append(\"\\n\");\n                    devInfo.append(\"Device Manufacturer: \").append(Build.MANUFACTURER).append(\"\\n\");\n                    devInfo.append(\"Device Model       : \").append(Build.MODEL).append(\"\\n\");\n                    devInfo.append(\"Android Version    : \").append(Build.VERSION.RELEASE).append(\"\\n\");\n                    devInfo.append(\"Android SDK        : \").append(Build.VERSION.SDK_INT).append(\"\\n\");\n                    devInfo.append(\"App VersionName    : \").append(versionName).append(\"\\n\");\n                    devInfo.append(\"App VersionCode    : \").append(versionCode).append(\"\\n\");\n                    devInfo.append(\"************* Crash Head ****************\\n\");\n                    devInfo.append(\"\\n\").append(fullStackTrace);\n\n                    String errorLog = devInfo.toString();\n\n                    try {\n                        writeFile(crashFile, errorLog);\n                    } catch (IOException ignored) {\n                    }\n\n                    Toast.makeText(app, \"Game has crashed unexpectedly\", Toast.LENGTH_LONG).show();\n                    Toast.makeText(app, \"Log saved to: \" + String.valueOf(crashFile).replace(\"/storage/emulated/0/\", \"\"), Toast.LENGTH_LONG).show();\n\n                    Log.e(\"AppCrash\", \"Done\");\n\n                    System.exit(2);\n                }\n\n                private void writeFile(File file, String content) throws IOException {\n                    File parentFile = file.getParentFile();\n                    if (parentFile != null && !parentFile.exists()) {\n                        parentFile.mkdirs();\n                    }\n                    file.createNewFile();\n                    FileOutputStream fos = new FileOutputStream(file);\n                    fos.write(content.getBytes());\n                    try {\n                        fos.close();\n                    } catch (IOException e) {\n                    }\n                }\n            });\n    }\n}\n","size_bytes":6121},"app/src/main/java/uk/lgl/modmenu/ESPView.java":{"content":"package uk.lgl.modmenu;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.Typeface;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport java.util.Date;\nimport android.graphics.PorterDuff;\nimport java.text.SimpleDateFormat;\nimport android.graphics.Rect;\nimport android.graphics.drawable.GradientDrawable;\npublic class ESPView extends View implements Runnable {\n    int FPS = 60;\n    Paint mFilledPaint;\n    Paint mStrokePaint;\n    Paint mTextPaint;\n    Thread mThread;\n    long sleepTime;\n    Date time;\n    int screenWidth;\n    int screenHeight;\n\n    public ESPView(Context context) {\n        super(context, (AttributeSet) null, 0);\n        InitializePaints();\n        setFocusableInTouchMode(false);\n        setBackgroundColor(0);\n        this.time = new Date();\n        this.sleepTime = (long) (1000 / this.FPS);\n        this.mThread = new Thread(this);\n        this.mThread.start();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (canvas != null && getVisibility() == VISIBLE) {\n            ClearCanvas(canvas);\n            screenWidth = (canvas.getWidth() / 2);\n            screenHeight = (canvas.getHeight());\n            FloatingModMenuService.DrawOn(this, canvas);\n            //Floater.Teste(this, canvas, screenWidth -(screenWidth), screenHeight -(screenHeight));\n        }\n    }\n\n    @Override\n    public void run() {\n        android.os.Process.setThreadPriority(10);\n        while (this.mThread.isAlive() && !this.mThread.isInterrupted()) {\n            try {\n                long currentTimeMillis = System.currentTimeMillis();\n                postInvalidate();\n                Thread.sleep(Math.max(Math.min(0, this.sleepTime - (System.currentTimeMillis() - currentTimeMillis)), this.sleepTime));\n            } catch (InterruptedException e) {\n                Log.e(\"OverlayThread\", e.getMessage());\n            }\n        }\n    }\n\n    public void InitializePaints() {\n\n        this.mStrokePaint = new Paint();\n        \n\n        this.mFilledPaint = new Paint();\n        this.mFilledPaint.setStyle(Paint.Style.FILL);\n        this.mFilledPaint.setAntiAlias(true);\n\n        this.mTextPaint = new Paint();\n        this.mTextPaint.setAntiAlias(true);\n        this.mTextPaint.setTextAlign(Paint.Align.CENTER);\n    }\n\n\t\n\t\n\tpublic void DrawCustomColor(Canvas cvs, int a, int r, int g, int b, int x, int y, int width, int height) {\n        int colors[] = {Color.TRANSPARENT, Color.RED, Color.TRANSPARENT};\n        GradientDrawable mDrawable = new GradientDrawable(GradientDrawable.Orientation.RIGHT_LEFT, colors);\n        mDrawable.setShape(GradientDrawable.RECTANGLE);\n        mDrawable.setGradientRadius(2.0f * 60);\n        Rect mRect = new Rect(x,y,width,height);\n        mDrawable.setBounds(mRect);\n        cvs.save();\n        mDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n        mDrawable.draw(cvs);\n        cvs.restore();\n    }\n\n\tpublic void DrawCustomText(Canvas cvs, int a, int r, int g, int b, float stroke, String txt, float posX, float posY, float size) {\n        mTextPaint.setColor(Color.rgb(r, g, b));\n        mTextPaint.setAlpha(a);\n\t\tmTextPaint.setTypeface(Typeface.MONOSPACE);      \n\n        if (getRight() > 1920 || getBottom() > 1920)\n            mTextPaint.setTextSize(4.0f + size);\n        else if (getRight() == 1920 || getBottom() == 1920)\n            mTextPaint.setTextSize(size + 2.0f);\n        else\n            mTextPaint.setTextSize(size);\n\n        cvs.drawText(txt, posX, posY, mTextPaint);\n    }\n    public void ClearCanvas(Canvas cvs) {\n        cvs.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);\n    }\n\n    public void DrawLine(Canvas cvs, int a, int r, int g, int b, float lineWidth, float fromX, float fromY, float toX, float toY) {\n        mStrokePaint.setColor(Color.rgb(r, g, b));\n        mStrokePaint.setAlpha(a);\n        mStrokePaint.setStrokeWidth(lineWidth);\n        cvs.drawLine(fromX, fromY, toX, toY, mStrokePaint);\n    }\n\n    public void DrawText(Canvas cvs, int a, int r, int g, int b, float stroke, String txt, float posX, float posY, float size) {\n        mTextPaint.setColor(Color.rgb(r, g, b));\n        mTextPaint.setAlpha(a);\n\t\tmTextPaint.setTypeface(Typeface.MONOSPACE);      \n\t\t\n        if (getRight() > 1920 || getBottom() > 1920)\n            mTextPaint.setTextSize(4.0f + size);\n        else if (getRight() == 1920 || getBottom() == 1920)\n            mTextPaint.setTextSize(size + 2.0f);\n        else\n            mTextPaint.setTextSize(size);\n\n        cvs.drawText(txt, posX, posY, mTextPaint);\n    }\n\n    public void DrawCircle(Canvas cvs, int a, int r, int g, int b, float stroke, float posX, float posY, float radius) {\n        mStrokePaint.setColor(Color.rgb(r, g, b));\n        mStrokePaint.setAlpha(a);\n        mStrokePaint.setStrokeWidth(stroke);\n        cvs.drawCircle(posX, posY, radius, mStrokePaint);\n    }\n\n    public void DrawFilledCircle(Canvas cvs, int a, int r, int g, int b, float posX, float posY, float radius) {\n        mFilledPaint.setColor(Color.rgb(r, g, b));\n        mFilledPaint.setAlpha(a);\n        cvs.drawCircle(posX, posY, radius, mFilledPaint);\n    }\n\n    public void DrawRect(Canvas cvs, int a, int r, int g, int b, int stroke, float x, float y, float width, float height) {\n        mStrokePaint.setStrokeWidth(stroke);\n        mStrokePaint.setColor(Color.rgb(r, g, b));\n        mStrokePaint.setAlpha(a);\n        cvs.drawRect(x, y, x + width, y + height, mStrokePaint);\n    }\n\n    public void DrawFilledRect(Canvas cvs, int a, int r, int g, int b, float x, float y, float width, float height) {\n        mFilledPaint.setColor(Color.rgb(r, g, b));\n        mFilledPaint.setAlpha(a);\n        cvs.drawRect(x, y, x + width, y + height, mFilledPaint);\n    }\n}\n\n\n","size_bytes":5867},"app/src/main/java/uk/lgl/modmenu/FloatingModMenuService.java":{"content":"package uk.lgl.modmenu;\n\nimport android.annotation.TargetApi;\nimport android.app.ActivityManager;\nimport android.app.ActivityManager.RunningAppProcessInfo;\nimport android.app.AlertDialog;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.ColorStateList;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.PixelFormat;\nimport android.graphics.Bitmap;\nimport android.graphics.PorterDuff;\nimport android.graphics.Typeface;\nimport android.media.MediaPlayer;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.graphics.drawable.Drawable;\nimport android.text.Html;\nimport android.text.InputFilter;\nimport android.text.InputType;\nimport android.text.method.DigitsKeyListener;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.inputmethod.InputMethodManager;\nimport android.webkit.WebSettings;\nimport android.webkit.WebView;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.RelativeLayout;\nimport android.widget.ScrollView;\nimport android.widget.SeekBar;\nimport android.widget.Spinner;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport uk.lgl.modmenu.ESPView;\nimport uk.lgl.modmenu.Utils;\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\nimport android.content.res.ColorStateList;\nimport android.content.res.AssetManager;\nimport java.io.IOException;\nimport android.content.DialogInterface;\n\nimport android.graphics.drawable.ColorDrawable;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.PixelFormat;\nimport android.graphics.PorterDuff;\nimport android.graphics.Typeface;\nimport android.media.MediaPlayer;\nimport android.widget.ProgressBar;\nimport android.os.Looper;\n\nimport android.graphics.drawable.BitmapDrawable;\nimport static uk.lgl.modmenu.StaticActivity.cacheDir;\nimport android.net.ConnectivityManager;\nimport java.net.HttpURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.net.URL;\nimport android.os.AsyncTask;\nimport android.annotation.SuppressLint;\nimport java.io.InputStreamReader;\nimport android.widget.LinearLayout.LayoutParams;\nimport android.widget.CheckBox;\nimport android.widget.RadioButton;\nimport android.widget.RadioGroup;\nimport android.util.DisplayMetrics;\nimport android.transition.Visibility;\nimport java.util.Calendar;\nimport android.animation.ArgbEvaluator;\nimport android.animation.ValueAnimator;\nimport android.animation.TimeAnimator;\nimport android.graphics.drawable.RippleDrawable;\nimport static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\nimport static android.widget.RelativeLayout.ALIGN_PARENT_LEFT;\nimport static android.widget.RelativeLayout.ALIGN_PARENT_RIGHT;\npublic class FloatingModMenuService extends Service {\n\tfinal int TEXT_COLOR = Color.parseColor(\"#82CAFD\");\n    final int TEXT_COLOR_2 = Color.parseColor(\"#FFFFFF\");\n    final int BTN_COLOR = Color.parseColor(\"#1C262D\");\n    final int MENU_BG_COLOR = Color.parseColor(\"#DD1C2A35\"); //#AARRGGBB\n    final int MENU_FEATURE_BG_COLOR = Color.parseColor(\"#FF171E24\"); //#AARRGGBB\n    final int MENU_WIDTH = 250;\n    final int MENU_HEIGHT = 300;\n    final float MENU_CORNER = 20f;\n    final int ICON_SIZE = 50;\n    final float ICON_ALPHA = 0.5f; //Transparent\n    private MediaPlayer FXPlayer;\n    public View mFloatingView;\n    private Button close;\n    private Button kill;\n    private LinearLayout mButtonPanel;\n    public RelativeLayout mCollapsed;\n    public LinearLayout mExpanded;\n    private RelativeLayout mRootContainer;\n    public WindowManager mWindowManager;\n    public WindowManager.LayoutParams params;\n    private LinearLayout patches;\n\tprivate LinearLayout patches2;\n    private FrameLayout rootFrame;\n    private ImageView startimage;\n\tprivate Drawable imagem;\n\tprivate Drawable logo;\n    private LinearLayout view1;\n    private LinearLayout view2;\n\tprivate GradientDrawable thumb;\n\n\t//Canvas \n\tprivate ESPView overlayView;\n\tpublic static native void DrawOn(ESPView espView, Canvas canvas);\n\tprivate WindowManager.LayoutParams espParams;\n    private native String ForegroundGravity();\n    private native String Gravity();\n    private AlertDialog alert;\n    private EditText edittextvalue;\n    private ImageView BadLogo2;\n    private static final String TAG = \"Mod Menu\";\n\n    private LinearLayout.LayoutParams hr;\n\n    //initialize methods from the native library\n    public static native String Toast();\n\n    private  GradientDrawable gd = new GradientDrawable();\n\tprivate  ValueAnimator animator;\n\tprivate  ValueAnimator animator_c;\n\n    public native void Changes(int feature, int value);\n\n    private native String[] getFeatureList();\n\n\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    //Override our Start Command so the Service doesnt try to recreate itself when the App is closed\n    public int onStartCommand(Intent intent, int i, int i2) {\n        return Service.START_NOT_STICKY;\n    }\n\n    private int getLayoutType() {\n        if (Build.VERSION.SDK_INT >= 26) {\n            return 2038;\n        }\n        if (Build.VERSION.SDK_INT >= 24) {\n            return 2002;\n        }\n        if (Build.VERSION.SDK_INT >= 23) {\n            return 2005;\n        }\n        return 2003;\n    }\n\n\tprivate void DrawCanvas() {\n        WindowManager.LayoutParams layoutParams;\n        this.espParams = layoutParams = new WindowManager.LayoutParams(-1, -1, this.getLayoutType(), 56, -3);\n        layoutParams.gravity = 8388659;\n        this.espParams.x = 0;\n        this.espParams.y = 0;\n        this.mWindowManager.addView((View)this.overlayView, (ViewGroup.LayoutParams)this.espParams);\n    }\n\n    //When this Class is called the code in this function will be executed\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        System.loadLibrary(\"MRKILLER2.5\");\n\t\tthis.overlayView = new ESPView((Context)this);\n        initFloating();\n        //CreateMenuList();\n\t\tDrawCanvas();\n\t\t//l  initAlertDiag();\n\n\t\t/*\n\t\t final Handler handler = new Handler();\n\t\t handler.post(new Runnable() {\n\t\t public void run() {\n\t\t handler.postDelayed(this, 1000);*/\n    }\n\n    private void initFloating() {\n        rootFrame = new FrameLayout(getBaseContext()); // Global markup\n        mRootContainer = new RelativeLayout(getBaseContext()); // Markup on which two markups of the icon and the menu itself will be placed\n        mCollapsed = new RelativeLayout(getBaseContext()); // Markup of the icon (when the menu is minimized)\n        mExpanded = new LinearLayout(getBaseContext()); // Menu markup (when the menu is expanded)\n\t\tAssetManager assetManager = getAssets();\n        view1 = new LinearLayout(getBaseContext());\n        patches = new LinearLayout(getBaseContext());\n\t\tpatches2 = new LinearLayout(getBaseContext());\n        view2 = new LinearLayout(getBaseContext());\n        mButtonPanel = new LinearLayout(getBaseContext()); // Layout of option buttons (when the menu is expanded)\n\t\t/*\n\t\t Toast.makeText(this, (Html.fromHtml(\"AutoBypass Activated!!!!\")), Toast.LENGTH_LONG).show();\n\t\t Toast.makeText(this, (Html.fromHtml(\"Functions Will Load Soon After Bypass..........\")), Toast.LENGTH_LONG).show();\n\t\t */\n\n        mButtonPanel = new LinearLayout(getBaseContext());\n        rootFrame.setLayoutParams(new FrameLayout.LayoutParams(-1, -1));\n\t\tmRootContainer.setLayoutParams(new FrameLayout.LayoutParams(-2, -2));\n\t\tmCollapsed.setLayoutParams(new RelativeLayout.LayoutParams(-2, -2));\n\t\tmCollapsed.setVisibility(View.GONE);\n\n\t\tLinearLayout.LayoutParams layoutParams3 = new LinearLayout.LayoutParams(dp(55), dp(55));\n        layoutParams3.topMargin = dp(15);\n\n        startimage = new ImageView(getBaseContext());\n        startimage.setLayoutParams(layoutParams3);\n        InputStream inputStream_close3 = null;\n        try {\n            inputStream_close3 = assetManager.open(\"mrkiller2.5.png\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        Drawable ic_close3 = Drawable.createFromStream(inputStream_close3, null);\n        startimage.setImageAlpha(225);\n        startimage.setImageDrawable(ic_close3);\n\n        BadLogo2 = new ImageView(this);\n        RelativeLayout.LayoutParams BadLogo2_LayoutParams = new RelativeLayout.LayoutParams(-0, -2);\n        BadLogo2.setLayoutParams(new RelativeLayout.LayoutParams(-2, -2));\n        BadLogo2_LayoutParams.addRule(0, -0);\n        BadLogo2_LayoutParams.setMarginEnd((int) ((0.0f) + 0.0f));\n        BadLogo2.getLayoutParams().height = dp(0);\n        BadLogo2.getLayoutParams().width = dp(0);\n        BadLogo2.requestLayout();\n        InputStream inputStream_icone2 = null;\n        try {\n            inputStream_icone2 = assetManager.open(\"mrkiller2.5.png\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        Drawable icone2 = Drawable.createFromStream(inputStream_icone2, null);\n        BadLogo2.setImageDrawable(icone2);\n        ((ViewGroup.MarginLayoutParams) this.BadLogo2.getLayoutParams()).leftMargin = convertDipToPixels(0);\n\n\n\t\tmExpanded = new LinearLayout(this);\n        mExpanded.setVisibility(View.VISIBLE);\n        mExpanded.setBackgroundColor(Color.rgb(0, 0, 0));\n        mExpanded.setOrientation(1);\n        mExpanded.setAlpha(0.95f);\n        android.graphics.drawable.GradientDrawable BGHGBDC = new android.graphics.drawable.GradientDrawable();\n        BGHGBDC.setColor(Color.parseColor(\"#292828\"));\n\t\tBGHGBDC.setStroke(4, Color.parseColor(\"#EAFF00\"));\n        BGHGBDC.setCornerRadius(8);\n        mExpanded.setBackground(BGHGBDC);\n        mExpanded.setPadding(0, 0, 0, 0);\n        mExpanded.setLayoutParams(new LinearLayout.LayoutParams(dp(225), -2)); //Dp PSTeam 200, 284\n\n\n        ScrollView scrollView = new ScrollView(this);\n        scrollView.setLayoutParams(new LinearLayout.LayoutParams(-1, dp(185)));\n        LinearLayout linearLayout2 = new LinearLayout(this);\n        linearLayout2.setLayoutParams(new LinearLayout.LayoutParams(dp(170), -2));\n        linearLayout2.setBackgroundColor(Color.TRANSPARENT);\n        linearLayout2.setOrientation(1);\n\n        view1.setLayoutParams(new LinearLayout.LayoutParams(-1, 2));\n        view1.setBackgroundColor(Color.argb(255,75,0,225));\n        view1.setPadding(0, 0, 0, 0);\n        patches.setLayoutParams(new LinearLayout.LayoutParams(-1, -1));\n        patches.setOrientation(1);\n        patches2.setLayoutParams(new LinearLayout.LayoutParams(-1, -1));\n        patches2.setOrientation(1);\n\n        view2.setLayoutParams(new LinearLayout.LayoutParams(-1, 2));\n        view2.setBackgroundColor(Color.argb(255,75,0,225));\n        view2.setPadding(0, 0, 0, 0);\n\n        mButtonPanel.setLayoutParams(new LinearLayout.LayoutParams(-2, -2));\n        final ProgressBar Loading = new ProgressBar(this);\n        TextView Bar = new TextView(this);\n        TextView VersaoFF = new TextView(this);\n        Loading.setForegroundGravity(Gravity.CENTER);\n        Bar.append(new String(ForegroundGravity()));\n        VersaoFF.append(new String(Gravity()));\n        Loading.setPadding(0, 10, 0, 10);\n        final Handler handlers = new Handler(Looper.getMainLooper());\n        handlers.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tLoading.setVisibility(View.GONE);\n\t\t\t\t\tCreateMenuList();\n\t\t\t\t}\n\t\t\t}, 3000);\n\n\t\tLinearLayout title = new LinearLayout(this);\n        // TextView View = new TextView(this);\n        LinearLayout.LayoutParams layoutParams5 = new LinearLayout.LayoutParams(-2, -2);\n        layoutParams5.gravity = 20;\n        layoutParams5.leftMargin = dp(25);\n        Bar.setTextSize(19.5f);\n        Bar.setTextColor(Color.parseColor(\"YELLOW\"));\n        title.setOrientation(0);\n        title.setPadding(dp(15), dp(9), dp(9), dp(9));\n        Bar.setTypeface(null, Typeface.BOLD_ITALIC);\n        Bar.setLayoutParams(layoutParams5);\n        title.setLayoutParams(new LinearLayout.LayoutParams(-1, -2));\n        LinearLayout.LayoutParams VersaoFF2 = new LinearLayout.LayoutParams(-2, -2);\n\n        VersaoFF.setTextColor(-1);\n\t\tVersaoFF.setTextSize(13.0f);\n\t\tVersaoFF.setTypeface((Typeface) null, 1);\n\t\tVersaoFF.setGravity(Gravity.CENTER);\n        VersaoFF.setPadding(0,0,0,2);\n\t    VersaoFF.setTextColor(Color.parseColor(\"blue\"));\n\n\n        RelativeLayout relativeLayout = new RelativeLayout(this);\n        relativeLayout.setPadding(0, 0, 0, 0);\n        relativeLayout.setLayoutParams(new RelativeLayout.LayoutParams(dp(-2), dp(33)));\n\n\n        close = new Button(this);\n        close.setBackgroundColor(Color.parseColor(\"black\"));\n        close.setTextSize(14);\n        close.setPadding(3, 2, 2, 2);\n        close.append(new String(\"CLOSE\"));\n        close.setTextColor(Color.parseColor(\"red\"));\n        android.graphics.drawable.GradientDrawable JCFBCJE = new android.graphics.drawable.GradientDrawable();\n        JCFBCJE.setColor(Color.parseColor(\"blue\"));\n        JCFBCJE.setCornerRadius(7);\n        close.setBackground(JCFBCJE);\n\n        new LinearLayout.LayoutParams(-1, dp(25)).topMargin = dp(2);\n        rootFrame.addView(mRootContainer);\n        this.patches.addView(Loading);\n        mRootContainer.addView(mCollapsed);\n        mRootContainer.addView(mExpanded);\n        mCollapsed.addView(startimage);\n        mExpanded.addView(title);\n        title.addView(BadLogo2);\n        title.addView(Bar);\n        mExpanded.addView(scrollView);\n        scrollView.addView(patches);\n        mExpanded.addView(VersaoFF);\n        relativeLayout.addView(close);\n        mFloatingView = rootFrame;\n        mExpanded.addView(relativeLayout);\n\n        if (Build.VERSION.SDK_INT >= 26) {\n            params = new WindowManager.LayoutParams(-2, -2, 2038, 8, -3);\n        } else {\n            params = new WindowManager.LayoutParams(-2, -2, 2002, 8, -3);\n        }\n\n        WindowManager.LayoutParams layoutParams4 = params;\n        layoutParams4.gravity = 51;\n        layoutParams4.x = 0;\n        layoutParams4.y = 50;\n        mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);\n        mWindowManager.addView(mFloatingView, params);\n        RelativeLayout relativeLayout2 = mCollapsed;\n        LinearLayout linearLayout = mExpanded;\n        mFloatingView.setOnTouchListener(onTouchListener());\n        startimage.setOnTouchListener(onTouchListener());\n        initMenuButton(relativeLayout2, linearLayout);\n    }\n\n    private View.OnTouchListener onTouchListener() {\n        return new View.OnTouchListener() {\n            final View collapsedView = mCollapsed;\n            final View expandedView = mExpanded;\n            private float initialTouchX;\n            private float initialTouchY;\n            private int initialX;\n            private int initialY;\n            public boolean onTouch(View view, MotionEvent motionEvent) {\n                switch (motionEvent.getAction()) {\n                    case MotionEvent.ACTION_DOWN:\n                        initialX = params.x;\n                        initialY = params.y;\n                        initialTouchX = motionEvent.getRawX();\n                        initialTouchY = motionEvent.getRawY();\n                        return true;\n                    case MotionEvent.ACTION_UP:\n                        int rawX = (int) (motionEvent.getRawX() - initialTouchX);\n                        int rawY = (int) (motionEvent.getRawY() - initialTouchY);\n                        //The check for Xdiff <10 && YDiff< 10 because sometime elements moves a little while clicking.\n                        //So that is click event.\n                        if (rawX < 10 && rawY < 10 && isViewCollapsed()) {\n                            //When user clicks on the image view of the collapsed layout,\n                            //visibility of the collapsed layout will be changed to \"View.GONE\"\n                            //and expanded view will become visible.\n                            collapsedView.setVisibility(View.GONE);\n                            expandedView.setVisibility(View.VISIBLE);\n                            //Toast.makeText(FloatingModMenuService.this, Html.fromHtml(Toast()), Toast.LENGTH_SHORT).show();\n                        }\n                        return true;\n                    case MotionEvent.ACTION_MOVE:\n                        //Calculate the X and Y coordinates of the view.\n                        params.x = initialX + ((int) (motionEvent.getRawX() - initialTouchX));\n                        params.y = initialY + ((int) (motionEvent.getRawY() - initialTouchY));\n                        //Update the layout with new X & Y coordinate\n                        mWindowManager.updateViewLayout(mFloatingView, params);\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        };\n    }\n\n\tprivate boolean hide = false;\n    private void initMenuButton(final View view2, final View view3) {\n        startimage.setOnClickListener(new View.OnClickListener() {\n                public void onClick(View view) {\n                    view2.setVisibility(View.GONE);\n                    view3.setVisibility(View.VISIBLE);\n                }\n            });\n\t\tclose.setOnClickListener(new View.OnClickListener() {\n\t\t\t\tpublic void onClick(View view) {\n\t\t\t\t\tif (hide) {\n\t\t\t\t\t\tview2.setVisibility(View.VISIBLE);\n\t\t\t\t\t\tview2.setAlpha(0);\n\t\t\t\t\t\tview3.setVisibility(View.GONE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tview2.setVisibility(View.VISIBLE);\n\t\t\t\t\t\tview2.setAlpha(0.95f);\n\t\t\t\t\t\tview3.setVisibility(View.GONE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n    }\n\n    private void CreateMenuList() {\n        String[] listFT = getFeatureList();\n        for (int i = 0; i < listFT.length; i++) {\n            final int feature = i;\n            String str = listFT[i];\n\t\t\tif (str.contains(\"Toggle_\")) {\n\t\t\t\taddButton(str.replace(\"Toggle_\", \"\"), new InterfaceBtn() {\n\t\t\t\t\t\tpublic void OnWrite() {\n\t\t\t\t\t\t\tChanges(feature, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t} else if (str.contains(\"Toggle_\")) {\n\t\t\t\taddButton1(str.replace(\"Toggle_\", \"\"), new InterfaceBtn() {\n\t\t\t\t\t\tpublic void OnWrite() {\n\t\t\t\t\t\t\tChanges(feature, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t} else if (str.contains(\"Toggle_\")) {\n\t\t\t\taddButtonm(str.replace(\"Toggle_\", \"\"), new InterfaceBtn() {\n\t\t\t\t\t\tpublic void OnWrite() {\n\t\t\t\t\t\t\tChanges(feature, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t} else if (str.contains(\"CT_\")) {\n                addCategory(str.replace(\"CT_\", \"\"));\n\n\t\t\t} else if (str.contains(\"SB_\")) {\n                String[] split = str.split(\"_\");\n                addSeekbarFly(split[1], Integer.parseInt(split[2]), Integer.parseInt(split[3]), new InterfaceInt() {\n\t\t\t\t\t\tpublic void OnWrite(int i) {\n\t\t\t\t\t\t\tChanges(feature, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t}\n\t\t}\n\t}\n\n    private TextView textView2;\n    private String featureNameExt;\n    private int featureNum;\n    private EditTextValue txtValue;\n\n    public class EditTextValue {\n        private int val;\n\n        public void setValue(int i) {\n            val = i;\n        }\n\n        public int getValue() {\n            return val;\n        }\n    }\n\n\tprivate void addCategory(String text) {\n        TextView textView = new TextView(this);\n        LinearLayout.LayoutParams layoutParams7 = new LinearLayout.LayoutParams(-1, -2);\n        textView.setText(text);\n        layoutParams7.setMargins(15, 3, 15, 3);\n        textView.setLayoutParams(layoutParams7);\n        textView.setPadding(5, 5, 5, 5);\n        textView.setTextSize(11);\n\t\ttextView.setTextColor(Color.parseColor( \"#FF0004\"));\n        textView.setGravity(17);\n\t\ttextView.setBackgroundColor(Color.parseColor( \"#FFF800\"));\n        patches.addView(textView);\n    }\n\n\n    public void addButton(String feature, final InterfaceBtn interfaceBtn) {\n        final Button button = new Button(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(-1, dp(40));\n        layoutParams.setMargins(15, 3, 15, 3);\n        button.setLayoutParams(layoutParams);\n        button.setPadding(5, 5, 5, 5);\n        button.setTextSize(13.0f);\n        button.setTextColor(Color.parseColor(\"WHITE\"));\n        button.setTypeface(Typeface.DEFAULT);\n        button.setAlpha(9.99f);\n        button.setGravity(17);\n        if (feature.contains(\"\")) {\n            feature = feature.replace(\"\", \"\");\n            //button.setText(Html.fromHtml(\"\" + feature + \" OFF\" + \"</font>\"));\n            button.setText(Html.fromHtml(\"<font>\" + feature + \" <font color='WHITE'>\" + \"OFF\" + \"</font>\"));\n            button.setBackgroundColor(Color.TRANSPARENT);\n            android.graphics.drawable.GradientDrawable GAFDJHE = new android.graphics.drawable.GradientDrawable();\n            GAFDJHE.setColor(Color.parseColor(\"Black\"));\n\t\t\tGAFDJHE.setStroke(6, Color.parseColor(\"#FFF800\"));\n            GAFDJHE.setCornerRadius(10);\n            android.graphics.drawable.RippleDrawable GAFDJHE_RE = new android.graphics.drawable.RippleDrawable(new android.content.res.ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.parseColor(\"Black\")}), GAFDJHE, null);\n            button.setBackground(GAFDJHE_RE);\n            if(Build.VERSION.SDK_INT >= 21) {\n                button.setElevation(5f); }\n            final String feature2 = feature;\n            button.setOnClickListener(new View.OnClickListener() {\n                    private boolean isActive = true;\n                    public void onClick(View v) {\n                        interfaceBtn.OnWrite();\n                        if (isActive) {\n                            //button.setText(Html.fromHtml(\"\" + feature2 + \" ON\" + \"</font>\"));\n                            button.setText(Html.fromHtml(\"<font>\" + feature2 + \" <font color='WHITE'>\" + \"ON\" + \"</font>\"));\n                            android.graphics.drawable.GradientDrawable ICECHHF = new android.graphics.drawable.GradientDrawable();\n                            ICECHHF.setColor(Color.argb(250, 10, 140, 180));\n\t\t\t\t\t\t\tICECHHF.setColor(Color.parseColor(\"blue\"));\n\t\t\t\t\t\t\tICECHHF.setStroke(6, Color.parseColor(\"#FFF800\"));\n\t\t\t\t\t\t\tbutton.setBackgroundColor(Color.TRANSPARENT);\n                            ICECHHF.setCornerRadius(10);\n                            android.graphics.drawable.RippleDrawable ICECHHF_RE = new android.graphics.drawable.RippleDrawable(new android.content.res.ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.parseColor(\"black\")}), ICECHHF, null);\n                            button.setBackground(ICECHHF_RE);\n                            if(Build.VERSION.SDK_INT >= 21) {\n                                button.setElevation(5f); }\n                            isActive = false;\n                            return;\n                        }\n                        //button.setText(Html.fromHtml(\"\" + feature2 + \" OFF\" + \"</font>\"));\n                        button.setText(Html.fromHtml(\"<font>\" + feature2 + \" <font color='WHITE'>\" + \"OFF\" + \"</font>\"));\n                        button.setBackgroundColor(Color.TRANSPARENT);\n                        android.graphics.drawable.GradientDrawable GAFDJHE = new android.graphics.drawable.GradientDrawable();\n                        GAFDJHE.setColor(Color.parseColor(\"Black\"));\n\t\t\t\t\t\tGAFDJHE.setStroke(6, Color.parseColor(\"#FFF800\"));\n                        GAFDJHE.setCornerRadius(10);\n                        android.graphics.drawable.RippleDrawable GAFDJHE_RE = new android.graphics.drawable.RippleDrawable(new android.content.res.ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.parseColor(\"red\")}), GAFDJHE, null);\n                        button.setBackground(GAFDJHE_RE);\n                        if(Build.VERSION.SDK_INT >= 21) {\n                            button.setElevation(5f); }\n                        isActive = true;\n                    }\n                });\n        } else {\n            button.setText(feature);\n            button.setAlpha(9.99f);\n            button.setBackgroundColor(Color.TRANSPARENT);\n            final String feature2 = feature;\n            button.setOnClickListener(new View.OnClickListener() {\n                    public void onClick(View v) {\n                        interfaceBtn.OnWrite();\n                        button.setAlpha(9.99f);\n                    }\n                });\n        }\n        patches.addView(button);\n    }\n\n\tpublic void addButtonm(String feature, final InterfaceBtn interfaceBtn) {\n        final TextView button = new TextView(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(-1, dp(35));\n        layoutParams.setMargins(4, 2, 4, 2);\n        button.setLayoutParams(layoutParams);\n        button.setTextSize(11);\n        button.setTextColor(-1);\n        button.setGravity(17);\n        GradientDrawable gradienteOff = new GradientDrawable();\n        gradienteOff.setShape(0);\n        gradienteOff.setStroke(5, Color.parseColor(\"#000000\"));\n        gradienteOff.setColor(Color.parseColor(\"#000000\"));\n        gradienteOff.setCornerRadii(new float[] { 40, 40, 40, 40, 80, 80, 80, 80 });\n        /*if (Build.VERSION.SDK_INT >= 21) {\n\t\t button.setElevation(90.0f);\n\t\t }*/\n        final GradientDrawable gradientDrawable = gradienteOff;\n        final RippleDrawable GIDDGID_RE = new RippleDrawable(new ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.RED}), gradienteOff, null);\n        gradientDrawable.setOrientation(GradientDrawable.Orientation.TL_BR);\n        button.setBackground(GIDDGID_RE);\n        button.setTypeface((Typeface) null, 1);\n        if (feature.contains(\"\")) {\n            feature = feature.replace(\"\", \"\");\n            button.setText(feature);\n            final String feature2 = feature;\n            button.setOnClickListener(new View.OnClickListener() {\n                    private boolean isActive = true;\n                    public void onClick(View v) {\n                        interfaceBtn.OnWrite();\n                        if (isActive) {\n                            button.setText(feature2);\n                            isActive = false;\n                            GradientDrawable gradienteOn = new GradientDrawable();\n                            gradienteOn.setShape(0);\n                            gradienteOn.setStroke(5, Color.parseColor(\"#000000\"));\n                            gradienteOn.setColor(Color.parseColor(\"#000000\"));\n                            RippleDrawable GIDDGID_RE2 = new RippleDrawable(new ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.RED}), gradienteOn, null);\n                            gradienteOn.setCornerRadii(new float[] { 40, 40, 40, 40, 80, 80, 80, 80 });\n                            /*if (Build.VERSION.SDK_INT >= 21) {\n\t\t\t\t\t\t\t button.setElevation(90.0f);\n\t\t\t\t\t\t\t }*/\n                            button.setBackground(GIDDGID_RE2);\n                            return;\n                        }\n                        button.setText(feature2);\n                        isActive = true;\n                        GradientDrawable gradienteOff = new GradientDrawable();\n                        gradienteOff.setShape(0);\n                        gradienteOff.setStroke(5, Color.parseColor(\"#000000\"));\n                        gradienteOff.setColor(Color.parseColor(\"#000000\"));\n                        gradienteOff.setCornerRadii(new float[] { 40, 40, 40, 40, 80, 80, 80, 80 });\n\n                        /*if (Build.VERSION.SDK_INT >= 21) {\n\t\t\t\t\t\t button.setElevation(90.0f);\n\t\t\t\t\t\t }*/\n                        final GradientDrawable gradientDrawable = gradienteOff;\n                        final RippleDrawable GIDDGID_RE = new RippleDrawable(new ColorStateList(new int[][]{new int[]{}}, new int[]{ Color.RED}), gradienteOff, null);\n                        gradientDrawable.setOrientation(GradientDrawable.Orientation.TL_BR);\n                        button.setBackground(GIDDGID_RE);\n                    }\n                });\n        } else {\n            button.setText(feature);\n\n            final String feature2 = feature;\n            button.setBackground(gradientDrawable);\n            button.setOnClickListener(new View.OnClickListener() {\n                    public void onClick(View v) {\n                        interfaceBtn.OnWrite();\n\n                    }\n                });\n        }\n        patches.addView(button);\n    }\n\n\tpublic void addButton1(String feature, final InterfaceBtn interfaceBtn) {\n\t\tfinal Button button = new Button(this);\n\t\tLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(-1, dp(35));\n\t\tlayoutParams.setMargins(4, 2, 4, 2);\n\t\tbutton.setLayoutParams(layoutParams);\n\t\tbutton.setTextSize(11);\n\t\tbutton.setBackground(Preferences.bbbbb_aaaaaaaa(this));\n\t\tbutton.setTextColor(-1);\n\t\tbutton.setGravity(17);\n\t\tbutton.setTypeface((Typeface) null, 1);\n\t\tif (feature.contains(\"\")) {\n\t\t\tfeature = feature.replace(\"\", \"\");\n\t\t\tbutton.setText(feature + \" ON\");\n\t\t\tfinal String feature2 = feature;\n\t\t\tbutton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\tprivate boolean isActive = true;\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tinterfaceBtn.OnWrite();\n\t\t\t\t\t\tif (isActive) {\n\t\t\t\t\t\t\tbutton.setText(feature2 + \" OFF\");\n\t\t\t\t\t\t\tisActive = false;\n\t\t\t\t\t\t\t//Toast.makeText(ctx, Html.fromHtml(feature2 + \"<font color='GREEN'>\"+\" ON</font>\"), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\t\tbutton.setBackground(Preferences.botoes(getBaseContext()));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbutton.setText(feature2 + \" ON\");\n\t\t\t\t\t\tisActive = true;\n\t\t\t\t\t\t//Toast.makeText(ctx, Html.fromHtml(feature2 + \"<font color='GREEN'>\"+\" OFF</font>\"), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\tbutton.setBackground(Preferences.bbbbb_aaaaaaaa(getBaseContext()));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else {\n\t\t\tbutton.setText(feature);\n\t\t\tfinal String feature2 = feature;\n\t\t\tbutton.setBackground(Preferences.botoes(this));\n\t\t\tbutton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tinterfaceBtn.OnWrite();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t\tpatches.addView(button);\n\t}\n\n\n\n\tprivate void addSeekbarFly(final String feature, final int prog, int max, final InterfaceInt interInt) {\n        LinearLayout linearLayout = new LinearLayout(this);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(-1, -1);\n        linearLayout.setPadding(10, 5, 0, 5);\n        linearLayout.setOrientation(LinearLayout.VERTICAL);\n        linearLayout.setGravity(18);\n        linearLayout.setLayoutParams(layoutParams);\n        linearLayout.setBackgroundColor(Color.TRANSPARENT);\n        LinearLayout view4 = new LinearLayout(this);\n        view4.setLayoutParams(new LinearLayout.LayoutParams(-1, 2));\n        LinearLayout view5 = new LinearLayout(this);\n        view5.setLayoutParams(new LinearLayout.LayoutParams(-1, 2));\n        final TextView textView = new TextView(this);\n        textView.setText(Html.fromHtml(\"\" + feature + \" : <font color='WHITE'>\" + \"0x\" + \"</font>\"));\n        textView.setTextColor(Color.WHITE);\n        textView.setTextSize(11.5f);\n        SeekBar seekBar = new SeekBar(this);\n        seekBar.setLayoutParams(new LinearLayout.LayoutParams(-1, -1));\n\t\tseekBar.getThumb().setColorFilter(Color.parseColor(\"BLUE\"), PorterDuff.Mode.SRC_IN);\n        seekBar.setMax(max);\n        seekBar.setProgress(prog);\n        final TextView textView2 = textView;\n        seekBar.getProgressDrawable().setColorFilter(Color.parseColor(\"#FFF800\"), PorterDuff.Mode.MULTIPLY);\n        seekBar.getThumb().setColorFilter(Color.parseColor(\"blue\"), PorterDuff.Mode.SRC_IN);\n        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n                public void onStartTrackingTouch(SeekBar seekBar) {\n                }\n                public void onStopTrackingTouch(SeekBar seekBar) {\n                }\n                int l;\n                public void onProgressChanged(SeekBar seekBar, int i, boolean z) {\n                    if (i == 0) {\n                        seekBar.setProgress(i);\n                        interInt.OnWrite(i);\n                        TextView textView = textView2;\n                        textView.setText(Html.fromHtml(\"\" + feature + \" : <font color='WHITE'>\" + \"0x\" + \"</font>\"));\n\n                        return;\n                    }\n                    interInt.OnWrite(i);\n                    textView.setText(Html.fromHtml(\"\" + feature + \" : <font color='WHITE'>\" + i + \"x</font>\"));\n\n                }\n            });\n\n        linearLayout.addView(textView);\n        linearLayout.addView(seekBar);\n        patches.addView(linearLayout);\n    }\n\n\n\n\n\n    boolean delayed;\n\n    public boolean isViewCollapsed() {\n        return mFloatingView == null || mCollapsed.getVisibility() == View.VISIBLE;\n    }\n\n    private int convertDipToPixels(int i) {\n        return (int) ((((float) i) * getResources().getDisplayMetrics().density) + 0.5f);\n    }\n\n    private int dp(int i) {\n        return (int) TypedValue.applyDimension(1, (float) i, getResources().getDisplayMetrics());\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (view2 != null) {\n            this.mWindowManager.removeView(view2);\n        }\n        View view = mFloatingView;\n        if (view != null) {\n            mWindowManager.removeView(view);\n        }\n    }\n\n    private boolean isNotInGame() {\n        RunningAppProcessInfo runningAppProcessInfo = new RunningAppProcessInfo();\n        ActivityManager.getMyMemoryState(runningAppProcessInfo);\n        return runningAppProcessInfo.importance != 100;\n    }\n\n    private interface InterfaceBtn {\n        void OnWrite();\n    }\n\n    private interface InterfaceInt {\n        void OnWrite(int i);\n    }\n\n    private interface InterfaceBool {\n        void OnWrite(boolean z);\n    }\n\n    private interface InterfaceStr {\n        void OnWrite(String s);\n    }\n}\n\n","size_bytes":34264},"app/src/main/java/uk/lgl/modmenu/MainActivity.java":{"content":"package uk.lgl.modmenu;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.text.format.Time;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.res.AssetManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.Process;\nimport android.provider.Settings;\nimport android.telephony.TelephonyManager;\nimport android.text.Html;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.widget.Toast;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.os.Looper;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.content.DialogInterface;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport uk.lgl.modmenu.R;\nimport android.content.pm.ActivityInfo;\nimport android.widget.ThemedSpinnerAdapter;\npublic class MainActivity extends Activity {\n\tpublic static final String APPLICATION_ID = \"uk.lgl.modmenu\";\n    public static final String BUILD_TYPE = \"debug\";\n    public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n    public static final int VERSION_CODE = 1;\n    public static final String VERSION_NAME = \"1.0\";\n\t\n\tprivate static final String TAG = \"Mod Menu\";\n    public static String FFMainActivity;\n    public static String cacheDir;\n    public String GameActivity = \"com.dts.freefireth\";\n    public boolean hasLaunched = false;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\t\tStaticActivity.FFMainActivity(this);\n        \n        Thread.setDefaultUncaughtExceptionHandler(\n            new Thread.UncaughtExceptionHandler() {\n                @Override\n                public void uncaughtException(Thread thread, Throwable e) {\n                    Log.e(\"AppCrash\", \"Error just lunched \");\n                    Log.e(\"Mod_menu\", \"Error. Game's main activity does not exist\");\n                }\n            });\n        if (!hasLaunched) {\n            try {\n                hasLaunched = true;\n                MainActivity.this.startActivity(new Intent(MainActivity.this, Class.forName(MainActivity.this.GameActivity)));\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n                Toast.makeText(MainActivity.this, \"Error just lunched \", Toast.LENGTH_LONG).show();\n                Toast.makeText(MainActivity.this, \"Error. Game's main activity does not exist\", Toast.LENGTH_LONG).show();\n                return;\n            }\n        }\n    }\n}\n","size_bytes":2864},"app/src/main/java/uk/lgl/modmenu/Preferences.java":{"content":"package uk.lgl.modmenu;\n\nimport android.content.Context; \nimport android.content.res.Resources; \nimport android.graphics.Bitmap; \nimport android.graphics.BitmapFactory; \nimport android.graphics.Color; \nimport android.graphics.drawable.BitmapDrawable; \nimport android.graphics.drawable.Drawable; \nimport android.graphics.drawable.GradientDrawable; \nimport android.graphics.drawable.StateListDrawable; \nimport android.util.Base64; \nimport android.util.DisplayMetrics; \nimport android.util.TypedValue; \n\npublic class Preferences {\n    public static native void lllllllllllllllll(int id);\n\n    public static native String YUMODZXD();\n\n    public static native String YUYUYUYU()\n\n    public static GradientDrawable bbbbb_aaaaaaaa(Context context) {\n        GradientDrawable gradientDrawable = new GradientDrawable();\n        gradientDrawable.setShape(0);\n        gradientDrawable.setStroke(3, Color.BLACK);\n        gradientDrawable.setColor(Color.parseColor(\"#FF0000\"));\n        gradientDrawable.setCornerRadii(new float[] { 20, 20, 10, 10, 20, 20, 10, 10 });\n\t\tgradientDrawable.setCornerRadius(TypedValue.applyDimension((int)1, (float)5.0f, (DisplayMetrics)context.getResources().getDisplayMetrics()));\n        return gradientDrawable;\n    }\n\n    public static StateListDrawable bbbbb_hhhhh(Context context) {\n        StateListDrawable stateListDrawable = new StateListDrawable();\n        stateListDrawable.addState(new int[]{16842919}, (Drawable)Preferences.bbbbb_aaaaaaaa(context));\n        stateListDrawable.addState(new int[]{16842908}, (Drawable)Preferences.bbbbb_aaaaaaaa(context));\n        stateListDrawable.addState(new int[]{-16842908, -16842919}, (Drawable)Preferences.botoes(context));\n        return stateListDrawable;\n    }\n\n    public static GradientDrawable botoes(Context context) {\n        GradientDrawable gradientDrawable = new GradientDrawable();\n        gradientDrawable.setShape(0);\n        gradientDrawable.setStroke(3, Color.BLACK);\n        gradientDrawable.setCornerRadius(0);\n        gradientDrawable.setCornerRadius(TypedValue.applyDimension((int)1, (float)5.0f, (DisplayMetrics)context.getResources().getDisplayMetrics()));\n        return gradientDrawable;\n    }\n\n    public static Drawable yu_icon(Context context, String string2) {\n        byte[] arrby = Base64.decode((String)string2, (int)0);\n        Bitmap bitmap = BitmapFactory.decodeByteArray((byte[])arrby, (int)0, (int)arrby.length);\n        return new BitmapDrawable(context.getResources(), bitmap);\n    }\n}\n","size_bytes":2493},"app/src/main/java/uk/lgl/modmenu/StaticActivity.java":{"content":"package uk.lgl.modmenu;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.res.AssetManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.Process;\nimport android.provider.Settings;\nimport android.telephony.TelephonyManager;\nimport android.text.Html;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport android.os.Looper;\n\npublic class StaticActivity {\n\n    private static final String TAG = \"Mod Menu\";\n    public static String cacheDir;\n\n    public static void FFMainActivity(final Context context) {\n\t\tString currentTime = new SimpleDateFormat(\"yyyyMMdd\").format(Calendar.getInstance().getTime());\n        Log.d(\"timeStamp\", currentTime);\n        Calendar date = new GregorianCalendar(2026, Calendar.JANUARY,22);\n        date.add(Calendar.DAY_OF_WEEK, 0); //28/01/2021\n        String expireTime = new SimpleDateFormat(\"yyyyMMdd\").format(date.getTime());\n\n        int intcurrentTime = Integer.parseInt(currentTime);\n        int intexpireTime = Integer.parseInt(expireTime);\n\n\n        if(intcurrentTime >= intexpireTime) {\n\n            Toast.makeText(context,(Html.fromHtml(\"<font color=RED>Mod Menu Expire,Check For More Updates!</font></b><font color=RED><b></b></font>\")), Toast.LENGTH_SHORT).show();\n\n            Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://t.me/itsRohitOp\"));\n\t\t\t//i.setData(Uri.parse(url));\n            context.startActivity(i);\n            final Handler handler = new Handler(Looper.getMainLooper());\n            handler.postDelayed(new Runnable() {\n                    @Override\n                    public void run() {\n                        //Do something after 7000ms\n                        System.exit(0);\n                    }\n                }, 7150);\n        }\n\t\t\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(context)) {\n            context.startActivity(new Intent(\"android.settings.action.MANAGE_OVERLAY_PERMISSION\",\n\t\t\t\t\t\t\t\t\t\t\t Uri.parse(\"package:\" + context.getPackageName())));\n            Process.killProcess(Process.myPid());\n        } else {\n\n            // Delay starting service to prevent function pointer issue\n            // Arcording to Guided Hacking:\n            // https://guidedhacking.com/threads/android-function-pointers-hooking-template-tutorial.14771/#post-90490\n            // The il2cpp lib sometimes don't loaded first which caused crash when declaring the function pointer.\n            // Instead splitting the function pointer, delay the service. The Il2Cpp will load first\n            // before the service start\n            Handler handler = new Handler();\n            handler.postDelayed(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tcontext.startService(new Intent(context, FloatingModMenuService.class));\n\t\t\t\t\t}\n\t\t\t\t}, 5000);\n        }\n\n        cacheDir = context.getCacheDir().getPath() + \"/\";\n\n        \n\t\t/* AssetManager assets = context.getAssets();\n\t\t String str2 = cacheDir + \"/Slider-Switch.ogg\";\n\t\t try {\n\t\t copyFile(assets.open(\"Slider-Switch.ogg\"), new FileOutputStream(str2));\n\t\t } catch (IOException e) {\n\t\t e.printStackTrace();\n\t\t }*/\n    }\n    /*private static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {\n\t byte[] bArr = new byte[1024];\n\t while (true) {\n\t int read = inputStream.read(bArr);\n\t if (read != -1) {\n\t outputStream.write(bArr, 0, read);\n\t } else {\n\t return;\n\t }\n\t }\n\t }*/\n}\n\n","size_bytes":3904},"app/src/main/java/uk/lgl/modmenu/Utils.java":{"content":"package uk.lgl.modmenu;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.os.Process;\nimport android.provider.Settings;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.widget.Toast;\nimport uk.lgl.modmenu.FloatingModMenuService;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport android.text.Html;\n\npublic class Utils {\n\n    public static void Start(final Context context) {\n            final Handler handler = new Handler(Looper.getMainLooper());\n            handler.postDelayed(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tString currentTime = new SimpleDateFormat(\"yyyyMMdd\").format(Calendar.getInstance().getTime());\n\t\t\t\t\t\tLog.d(\"timeStamp\", currentTime);\n\t\t\t\t\t\tCalendar date = new GregorianCalendar(2025, Calendar.MAY, 02);\n\t\t\t\t\t\tdate.add(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\t\tString expireTime = new SimpleDateFormat(\"yyyyMMdd\").format(date.getTime());\n\t\t\t\t\t\tint intcurrentTime = Integer.parseInt(currentTime);\n\t\t\t\t\t\tint intexpireTime = Integer.parseInt(expireTime);\n\t\t\t\t\t\tif(intcurrentTime >= intexpireTime) {\n                       // Dark     //Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{86,109,48,119,100,50,81,121,86,107,104,86,87,71,104,85,86,48,100,111,99,70,86,116,77,86,78,88,86,108,108,51,87,107,82,83,86,49,90,115,98,68,78,88,97,50,77,49,86,48,90,75,99,50,74,69,84,108,104,104,77,88,66,81,86,109,120,86,101,70,89,121,84,107,108,106,10,82,109,104,111,84,87,115,119,101,70,90,116,99,69,116,84,77,85,53,73,86,109,116,107,87,65,112,105,82,110,66,80,87,87,49,48,83,49,90,87,87,110,82,106,82,88,82,85,84,86,86,115,78,86,90,72,100,72,78,104,85,88,66,84,89,108,90,75,85,70,100,87,90,68,82,90,10,86,49,90,88,86,50,53,83,98,70,73,122,85,108,86,85,86,108,85,120,86,48,90,87,100,69,53,86,79,87,104,82,87,69,74,85,87,87,120,97,83,49,100,87,90,72,78,97,82,70,74,97,67,108,90,115,83,108,104,87,77,106,86,76,87,86,90,75,82,49,78,116,82,108,100,104,10,97,49,112,77,86,84,70,97,89,87,82,72,85,107,108,85,98,87,104,83,86,48,86,75,86,86,100,88,101,71,70,84,77,86,112,88,86,50,116,107,86,109,69,122,85,110,66,68,97,122,70,122,86,50,120,111,86,48,49,113,86,107,120,88,86,108,112,76,85,106,70,79,99,49,90,115,10,99,71,107,75,85,109,53,67,98,49,90,85,81,109,70,90,86,107,53,71,84,108,90,97,85,70,89,121,97,70,100,87,77,70,90,76,86,108,90,107,87,71,82,72,79,86,74,78,86,108,112,73,86,50,116,97,97,49,108,87,83,107,90,84,98,71,104,69,89,108,86,119,87,70,86,116,10,99,70,78,87,77,68,70,120,86,109,116,52,86,48,49,72,85,107,120,87,77,86,112,88,89,122,70,97,99,119,112,87,98,71,78,76,87,87,116,111,81,109,86,115,90,72,78,88,98,85,90,87,84,87,115,120,78,70,100,114,97,69,57,90,86,107,112,48,86,87,120,79,86,48,49,71,10,87,107,120,97,82,69,90,104,86,108,90,71,99,49,112,71,85,107,53,105,82,86,107,119,86,109,112,75,78,71,73,121,83,107,100,84,98,107,112,80,86,109,115,49,82,86,108,115,86,110,100,88,82,108,108,53,67,109,82,72,79,86,104,83,77,70,89,48,87,84,66,111,83,49,100,71,10,87,110,78,106,82,88,104,87,89,108,104,111,85,70,107,121,99,122,86,87,100,51,66,88,89,107,100,79,84,70,90,71,85,107,116,105,77,85,53,88,86,50,116,111,98,70,73,119,87,109,70,87,97,107,90,76,85,49,90,97,87,71,82,72,79,87,104,78,86,88,66,54,87,84,66,107,10,98,49,90,87,87,107,89,75,85,50,116,52,89,86,74,70,87,109,104,87,77,70,86,52,85,108,90,75,99,49,78,114,78,87,108,83,87,69,69,121,86,109,49,119,83,48,49,72,82,88,104,88,87,71,120,85,89,107,90,119,87,86,108,116,100,72,100,83,86,109,120,90,89,48,86,107,10,98,70,90,116,101,72,108,68,98,70,90,122,86,71,120,107,84,108,74,70,87,88,104,88,86,108,90,118,85,122,70,90,100,119,112,78,86,87,104,87,89,84,78,111,86,49,82,86,87,110,100,88,82,109,119,50,85,109,116,107,97,109,81,122,81,108,108,90,98,71,81,119,86,69,90,97,10,99,86,70,116,100,71,108,78,97,50,119,48,86,106,74,52,86,49,86,116,83,108,90,88,98,85,90,88,89,87,116,97,84,70,86,113,82,108,78,106,77,87,82,48,85,109,49,111,84,108,90,89,81,106,90,88,86,69,74,118,67,108,77,120,87,108,100,88,97,49,108,76,86,84,74,48,10,78,70,108,87,83,88,112,104,83,69,112,97,90,87,116,97,77,49,86,115,87,108,100,106,77,107,53,72,87,107,100,115,85,48,48,121,84,106,78,87,98,84,70,51,85,122,65,120,83,70,74,89,97,70,104,88,82,51,104,86,87,87,116,97,100,49,100,87,98,72,74,88,98,85,90,84,10,86,109,49,52,87,108,107,119,86,109,115,75,89,107,90,97,99,50,74,69,86,107,82,105,86,107,112,74,86,68,70,97,98,50,70,87,87,108,100,88,86,69,90,89,86,109,120,97,87,70,108,113,82,108,112,108,85,88,66,84,86,48,100,52,86,49,108,85,84,109,57,88,82,109,120,122,10,89,85,99,53,97,109,74,73,81,107,100,87,98,70,74,88,86,106,74,82,101,108,70,116,79,86,90,104,97,50,57,51,86,107,86,97,97,119,112,88,82,49,90,72,86,71,49,119,97,86,90,115,99,68,90,87,97,107,111,119,86,106,70,86,101,86,74,89,97,71,112,83,97,49,112,89,10,87,87,120,111,85,49,82,71,87,108,86,83,98,71,82,84,84,86,90,97,87,108,100,114,87,107,100,87,98,70,112,70,85,86,82,86,80,81,61,61}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT))));\n                            Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse(new String(new byte[]{104,116,116,112,115,58,47,47,119,119,119,46,121,111,117,116,117,98,101,46,99,111,109,47,99,104,97,110,110,101,108,47,85,67,119,122,122,71,111,100,120,45,75,88,48,119,86,71,69,102,98,120,80,117,52,65})));  \n\t\t\t\t\t\t\tcontext.startActivity(i);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 10000);\n        \n        if (Build.VERSION.SDK_INT < 23 || Settings.canDrawOverlays(context)) {\n            new Handler().postDelayed(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t//System.loadLibrary(\"anogs\");\n\t\t\t\t        //System.loadLibrary(\"il2cpp\");\n\t\t\t\t\t\t//System.loadLibrary(\"E\");\n\t\t\t\t\t\tcontext.startService(new Intent(context, FloatingModMenuService.class));\n\t\t\t\t\t\tString currentTime = new SimpleDateFormat(\"yyyyMMdd\").format(Calendar.getInstance().getTime());\n\t\t\t\t\t\tLog.d(\"timeStamp\", currentTime);\n\t\t\t\t\t\tCalendar date = new GregorianCalendar(2025, Calendar.MAY, 02);\n\t\t\t\t\t\tdate.add(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\t\tString expireTime = new SimpleDateFormat(\"yyyyMMdd\").format(date.getTime());\n\t\t\t\t\t\tint intcurrentTime = Integer.parseInt(currentTime);\n\t\t\t\t\t\tint intexpireTime = Integer.parseInt(expireTime);\n\t\t\t\t\t\tif(intcurrentTime >= intexpireTime) {\n\t\t\t\t\t\tToast.makeText(context, \"MOD EXPIRED SOON |SUBSCRIBE OUR CHANNEL & VISIT FOR NEW UPADATE \", Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t\tIntent i = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://youtube.com/@mr_killer_2_5?si=FPbXkFLN10l2bKpK\"));\n\t\t\t\t\t\t\tcontext.startActivity(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 4000);\n        } else {\n            context.startActivity(new Intent(\"android.settings.action.MANAGE_OVERLAY_PERMISSION\", Uri.parse(\"package:\" + context.getPackageName())));\n            Process.killProcess(Process.myPid());\n        }\n\t}\n}\n","size_bytes":7881}},"version":1}